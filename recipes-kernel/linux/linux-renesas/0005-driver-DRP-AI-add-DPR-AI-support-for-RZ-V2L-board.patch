From c0b05d0c4056289bc12e112a2406a269e7a3d3bc Mon Sep 17 00:00:00 2001
From: Vu Dang <vu.dang.te@renesas.com>
Date: Mon, 2 Oct 2023 16:54:19 +0700
Subject: [PATCH 5/6] driver: DRP-AI: add DPR-AI support for RZ/V2L board

Revision: v7.40
Apply these patches:
(from meta-rz-features/meta-rz-drpai/recipes-drpai/recipes-kernel/linux/linux-renesas)
	0001-ov5645-Add-VGA-720x480-and-720p-resloutions.patch
	0002-ov5645-Add-pixel-rate-support-for-each-mode.patch
	0003-rzg2l-csi-Add-BGR24-and-YUYV-support.patch
	0004-rzg2l-dma-Add-BGR24-and-YUYV-support.patch
	0005-update-ov5645-VGA-setting.patch
	0006-enable-u-dma-buf-function.patch
	0007-enable-drpai-drv.patch
	0008-WA-available-v4l2-memory-userptr.patch

Signed-off-by: Vu Dang <vu.dang.te@renesas.com>
---
 arch/arm64/boot/dts/renesas/r9a07g054.dtsi    |   20 +
 .../boot/dts/renesas/r9a07g054l2-dev.dts      |   15 +
 .../boot/dts/renesas/r9a07g054l2-smarc.dts    |   15 +
 drivers/Kconfig                               |    3 +
 drivers/Makefile                              |    1 +
 drivers/drpai/Kconfig                         |   14 +
 drivers/drpai/Makefile                        |    8 +
 drivers/drpai/drpai-core.c                    | 1476 +++++++
 drivers/drpai/drpai-core.h                    |   86 +
 drivers/drpai/drpai-if.c                      | 3657 +++++++++++++++++
 drivers/drpai/drpai-reg.h                     |  290 ++
 drivers/media/i2c/ov5645.c                    |  408 +-
 drivers/media/platform/rzg2l-cru/rzg2l-csi2.c |    2 +
 drivers/media/platform/rzg2l-cru/rzg2l-dma.c  |    8 +-
 include/linux/drpai.h                         |   22 +
 include/uapi/linux/drpai.h                    |  129 +
 mm/frame_vector.c                             |   33 +
 17 files changed, 6183 insertions(+), 4 deletions(-)
 create mode 100755 drivers/drpai/Kconfig
 create mode 100755 drivers/drpai/Makefile
 create mode 100755 drivers/drpai/drpai-core.c
 create mode 100755 drivers/drpai/drpai-core.h
 create mode 100755 drivers/drpai/drpai-if.c
 create mode 100755 drivers/drpai/drpai-reg.h
 create mode 100755 include/linux/drpai.h
 create mode 100755 include/uapi/linux/drpai.h

diff --git a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
index fda87bc6d035..ba75c5a3710a 100644
--- a/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a07g054.dtsi
@@ -1594,6 +1594,26 @@ csi2_to_cru: endpoint {
 				};
 			};
 		};
+
+		drpai0: drpai@12C00000 {
+			compatible = "renesas,rzv2l-drpai";
+			reg = <0 0x13000000 0 0x1000000>,
+				  <0 0x12C00000 0 0x400000>;
+			clocks = <&cpg CPG_MOD R9A07G054_STPAI_INITCLK>,
+					 <&cpg CPG_MOD R9A07G054_STPAI_ACLK>,
+					 <&cpg CPG_MOD R9A07G054_STPAI_MCLK>,
+					 <&cpg CPG_MOD R9A07G054_STPAI_DCLKIN>,
+					 <&cpg CPG_MOD R9A07G054_STPAI_ACLK_DRP>;
+			resets = <&cpg R9A07G054_STPAI_ARESETN>;
+			power-domains = <&cpg>;
+			sysctrl = <&sysc>;
+			clock-names = "intclk","aclk_drp","mclk","dclkin","aclk";
+			interrupts = <GIC_SPI 440 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 441 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 442 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 443 IRQ_TYPE_LEVEL_HIGH>;
+			status = "okay";
+		};
 	};
 
 	thermal-zones {
diff --git a/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts b/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts
index f9a7b730ec9e..0ad90b78c860 100644
--- a/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts
+++ b/arch/arm64/boot/dts/renesas/r9a07g054l2-dev.dts
@@ -67,6 +67,15 @@ mmngrbuf {
 	vspm_if {
 		compatible = "renesas,vspm_if";
 	};
+
+	udmabuf@0 {
+		compatible = "ikwzm,u-dma-buf";
+		device-name = "udmabuf0";
+		minor-number = <0>;
+		size = <0x4000000>; // 64MiB
+		dma-coherent;
+		memory-region = <&image_buf0>;
+	};
 };
 
 &ehci0 {
@@ -84,3 +93,9 @@ &ehci1 {
 &ohci1 {
 	memory-region = <&global_cma>;
 };
+
+&drpai0 {
+	memory-region = <&drp_reserved>;
+	linux-memory-region = < &{/memory@48000000} >; 
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts b/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts
index 26a1a2f60f9a..2d538eef5f21 100644
--- a/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts
+++ b/arch/arm64/boot/dts/renesas/r9a07g054l2-smarc.dts
@@ -39,4 +39,19 @@ isp_work0: SIMPLE_ISP {
 			reg = <0x0 0xB4000000 0x0 0x03000000>;
 		};
 	};
+
+	udmabuf@0 {
+		compatible = "ikwzm,u-dma-buf";
+		device-name = "udmabuf0";
+		minor-number = <0>;
+		size = <0x4000000>; // 64MiB
+		dma-coherent;
+		memory-region = <&image_buf0>;
+	};
+};
+
+&drpai0 {
+	memory-region = <&drp_reserved>;
+	linux-memory-region = < &{/memory@48000000} >; 
+	status = "okay";
 };
diff --git a/drivers/Kconfig b/drivers/Kconfig
index dcecc9f6e33f..63f231eb5708 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -235,4 +235,7 @@ source "drivers/interconnect/Kconfig"
 source "drivers/counter/Kconfig"
 
 source "drivers/most/Kconfig"
+
+source "drivers/drpai/Kconfig"
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 576228037718..354b8fd483bc 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -189,3 +189,4 @@ obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
+obj-$(CONFIG_DRPAI)		+= drpai/
diff --git a/drivers/drpai/Kconfig b/drivers/drpai/Kconfig
new file mode 100755
index 000000000000..834a35593401
--- /dev/null
+++ b/drivers/drpai/Kconfig
@@ -0,0 +1,14 @@
+#
+# DRP-AI subsystem configuration
+#
+
+menu "DRP-AI/DRP support"
+
+config DRPAI
+	tristate "DRP-AI support"
+	default y
+	help
+	  DRP-AI is a peripheral hardware that accelerates AI.
+	  If you want DRP-AI support, you should say Y here.
+
+endmenu
diff --git a/drivers/drpai/Makefile b/drivers/drpai/Makefile
new file mode 100755
index 000000000000..3d44ea4e2fc8
--- /dev/null
+++ b/drivers/drpai/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for DRP-AI/DRP.
+#
+
+obj-$(CONFIG_DRPAI)	+= drpai-core.o drpai-if.o
+
+
diff --git a/drivers/drpai/drpai-core.c b/drivers/drpai/drpai-core.c
new file mode 100755
index 000000000000..9a4d796af2c9
--- /dev/null
+++ b/drivers/drpai/drpai-core.c
@@ -0,0 +1,1476 @@
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#else
+#include "r_typedefs.h"
+#endif
+#include <linux/drpai.h>
+#include <linux/reset.h>
+#include "drpai-core.h"
+#include "drpai-reg.h"
+
+#if defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2M(A) conditional compilation */
+#define SET_STPC_CLKGEN_DIV                 (0x00030001)
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+#define SET_STPC_CLKGEN_DIV                 (0x00020001)
+#endif 
+
+#define DRP_ERRINT_MSK_REG_NUM              (6)
+#define DRP_ERRINT_STATUS_REG_NUM           (6)
+#define AIMAC_ERRINT_MSK_REG_NUM            (34)
+#define AIMAC_ERRINT_STATUS_REG_NUM         (35)
+#define SET_STPC_CLKGEN_CTRL                (0x00000001)
+#define SET_STPC_CLKGEN_RST                 (0x00000000)
+#define SET_STPC_CLKGEN_STBYWAIT_EN         (0x00000001)
+#define SET_STPC_CLKGEN_STBYWAIT_DI         (0x00000000)
+#define SET_STPC_CLKE_EN                    (0x100F030F)
+#define SET_DRPB_STPC_CLKE_EN               (0x300F030F)
+#define SET_STPC_CLKE_DI                    (0x00000000)
+#define SET_STPC_SFTRST_EN                  (0xFFFFFFFF)
+#define SET_STPC_SFTRST_DI                  (0x21F000F0)
+#define SET_DRPB_STPC_SFTRST_DI             (0x01F000F0)
+#define SET_DSCC_DCTL_CR                    (0x00000000)
+#define SET_DSCC_DCTL                       (0x00310001)
+#define SET_EXD0_STPC_CLKGEN_CTRL           (0x00000001)
+#define SET_EXD0_STPC_CLKGEN_RST            (0x00000000)
+#define SET_EXD0_STPC_CLKGEN_STBYWAI_EN     (0x00000001)
+#define SET_EXD0_STPC_CLKGEN_STBYWAI_DI     (0x00000000)
+#define SET_EXD0_STPC_CLKGEN_DIV            (0x00010000)
+#define SET_EXDX_STPC_CLKE_EN               (0x100F000F)
+#define SET_EXDX_STPC_CLKE_DI               (0x00000000)
+#define SET_CLKRSTCON_CLKE_EN               (0x00000001)
+#define SET_CLKRSTCON_CLKE_DI               (0x00000000)
+#define SET_EXDX_STPC_SFTRST_EN             (0xB1FF03FF)
+#define SET_EXDX_STPC_SFTRST_DI             (0xA1F003F0)
+#define SET_CLKRSTCON_SFTRST_EN             (0x0000001F)
+#define SET_CLKRSTCON_SFTRST_DI             (0x00000000)
+#define SET_EXD1_ODIF_INTMSK                (0x0300FFF7)
+#define SET_AID_DSCC_DCTL_CR                (0x00000000)
+#define SET_AID_DSCC_DCTL                   (0x00000001)
+#define SET_SYNCTBL_TBLX                    (0x0000FFFF)
+#define SET_IDMACIF_DSC_EN                  (0x00040001)
+#define SET_IDMACIF_MEMR_EN                 (0x00040101)
+#define SET_DSCC_DMA_EN                     (0x00000001)
+#define SET_DSCC_DMA_DI                     (0x00000000)
+#define DRPAI_RESERVED_DSCC_PAMON           (0)
+#define DRPAI_RESERVED_AID_DSCC_PAMON       (1)
+#define DRPAI_RESERVED_STPC_ERRINT_STS      (2)
+#define DRPAI_RESERVED_INTMON_ERRINT        (3)
+#define DRPAI_RESERVED_EXD1_ODIF_INT_IRQ    (4)
+#define DRPAI_RESERVED_EXD1_ODIF_INT_NOW    (5)
+#define DRPAI_RESERVED_SYNCTBL_TBL12        (6)
+#define DRPAI_RESERVED_SYNCTBL_TBL13        (7)
+#define DRPAI_RESERVED_SYNCTBL_TBL14        (8)
+#define DRPAI_RESERVED_SYNCTBL_TBL15        (9)
+
+static int32_t drp_init_tophalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+static int32_t drp_init_bottomhalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+static int32_t drp_start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc);
+static int32_t aimac_init(void __iomem *aimac_base_addr, int32_t ch);
+static int32_t aimac_start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock);
+static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit);
+static void aimac_clear_synctbl_tbl(void __iomem *aimac_base_addr);
+static void drp_clear_synctbl_tbl(void __iomem *drp_base_addr);
+static void drp_nmlint(void __iomem *drp_base_addr, drpai_odif_intcnto_t *odif_intcnto);
+static void drp_errint(void __iomem *drp_base_addr);
+static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset);
+static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset);
+static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset);
+static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset);
+static int32_t drp_cpg_reset(struct reset_control *rst_ctrl);
+
+static uint32_t exd0_odif_int_val;
+static uint32_t stpc_errint_sts_val;
+static uint32_t intmon_errint_val;
+
+/* DRP ERRINT */
+const static uint32_t drp_errint_msk_reg_tbl[DRP_ERRINT_MSK_REG_NUM][2] =
+{
+    {IDIF_EINTMSK       ,0x00F0F0F0}, {IDIF_EINTMSK_DSC ,0x00000000},
+    {ODIF_EINTMSK       ,0x07F0F0F0}, {IDMAC_INTME      ,0x55550000},
+    {ODMAC_INTME        ,0x5555FF80}, {RAC_EINTM        ,0x00000000},
+};
+const static uint32_t drp_errint_status_reg_tbl[DRP_ERRINT_STATUS_REG_NUM] =
+{
+    IDIF_EINT, IDIF_EINT_DSC, ODIF_EINT, IDMAC_INTSE,
+    ODMAC_INTSE, RAC_EINTS
+};
+const static char* drp_errint_status_reg_name_tbl[DRP_ERRINT_STATUS_REG_NUM] =
+{
+    "IDIF_EINT","IDIF_EINT_DSC","ODIF_EINT","IDMAC_INTSE",
+    "ODMAC_INTSE","RAC_EINTS"
+};
+/* AI-MAC ERRINT */
+const static uint32_t aimac_errint_msk_reg_tbl[AIMAC_ERRINT_MSK_REG_NUM][2] =
+{
+    {AID_IDIF_EINTMSK   ,0x07FEFEFE}, {AID_IDMAC_INTME      ,0x55550000},
+    {AIMRAC_EINTM       ,0x00000000}, {CMDSEL_ERRMSK        ,0x00000000},
+    {PRAM_INTMASK       ,0x00000000}, {OSEL_DO_MSK0         ,0x00000000},
+    {OSEL_DO_MSK1       ,0x00000000}, {OSEL_DO_MSK2         ,0x00000000},
+    {OSEL_DO_MSK3       ,0x00000000}, {OSEL_DO_MSK4         ,0x00000000},
+    {OSEL_DO_MSK5       ,0x00000000}, {OSEL_DO_MSK6         ,0x00000000},
+    {OSEL_DO_MSK7       ,0x00000000}, {OSEL_DO_MSK8         ,0x00000000},
+    {OSEL_DO_EN0        ,0x00000001}, {OSEL_DO_EN1          ,0x00000001},
+    {OSEL_DO_EN2        ,0x00000001}, {OSEL_DO_EN3          ,0x00000001},
+    {OSEL_DO_EN4        ,0x00000001}, {OSEL_DO_EN5          ,0x00000001},
+    {OSEL_DO_EN6        ,0x00000001}, {OSEL_DO_EN7          ,0x00000001},
+    {OSEL_DO_EN8        ,0x00000001}, {MACTOP_ERR_MSK       ,0x00000000},
+    {EXD0_IDIF_EINTMSK  ,0x07F0F0F0}, {EXD1_IDIF_EINTMSK    ,0x07F0F0F0},
+    {EXD0_ODIF_EINTMSK  ,0x07F0F0F0}, {EXD1_ODIF_EINTMSK    ,0x07F0F0F0},
+    {EXD0_IDMAC_INTME   ,0x55550000}, {EXD1_IDMAC_INTME     ,0x55550000},
+    {EXD0_ODMAC_INTME   ,0x55550000}, {EXD1_ODMAC_INTME     ,0x55550000},
+    {EXD0_RAC_EINTM     ,0x00000000}, {EXD1_RAC_EINTM       ,0x00000000},
+};
+const static uint32_t aimac_errint_status_reg_tbl[AIMAC_ERRINT_STATUS_REG_NUM] =
+{
+    AID_IDIF_EINT,AID_IDMAC_INTSE,AIMRAC_EINTS,CMDSEL_ERRSTS,PRAM_INT,
+    OSEL_DO_ESTS0,OSEL_DO_ESTS1,OSEL_DO_ESTS2,OSEL_DO_ESTS3,OSEL_DO_ESTS4,
+    OSEL_DO_ESTS5,OSEL_DO_ESTS6,OSEL_DO_ESTS7,OSEL_DO_ESTS8,OSEL_DO_FESTS0,
+    OSEL_DO_FESTS1,OSEL_DO_FESTS2,OSEL_DO_FESTS3,OSEL_DO_FESTS4,OSEL_DO_FESTS5,
+    OSEL_DO_FESTS6,OSEL_DO_FESTS7,OSEL_DO_FESTS8,MACTOP_ERR_STS,MACCTL_FERR_STS,
+    EXD0_IDIF_EINT,EXD1_IDIF_EINT,EXD0_ODIF_EINT,EXD1_ODIF_EINT,EXD0_IDMAC_INTSE,
+    EXD1_IDMAC_INTSE,EXD0_ODMAC_INTSE,EXD1_ODMAC_INTSE,EXD0_RAC_EINTS,EXD1_RAC_EINTS
+};
+const static char* aimac_errint_status_reg_name_tbl[AIMAC_ERRINT_STATUS_REG_NUM] =
+{
+    "AID_IDIF_EINT","AID_IDMAC_INTSE","AIMRAC_EINTS","CMDSEL_ERRSTS","PRAM_INT",
+    "OSEL_DO_ESTS0","OSEL_DO_ESTS1","OSEL_DO_ESTS2","OSEL_DO_ESTS3","OSEL_DO_ESTS4",
+    "OSEL_DO_ESTS5","OSEL_DO_ESTS6","OSEL_DO_ESTS7","OSEL_DO_ESTS8","OSEL_DO_FESTS0",
+    "OSEL_DO_FESTS1","OSEL_DO_FESTS2","OSEL_DO_FESTS3","OSEL_DO_FESTS4","OSEL_DO_FESTS5",
+    "OSEL_DO_FESTS6","OSEL_DO_FESTS7","OSEL_DO_FESTS8","MACTOP_ERR_STS","MACCTL_FERR_STS",
+    "EXD0_IDIF_EINT","EXD1_IDIF_EINT","EXD0_ODIF_EINT","EXD1_ODIF_EINT","EXD0_IDMAC_INTSE",
+    "EXD1_IDMAC_INTSE","EXD0_ODMAC_INTSE","EXD1_ODMAC_INTSE","EXD0_RAC_EINTS","EXD1_RAC_EINTS"
+};
+
+static int32_t drp_init_tophalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* DRP Init operation: No.1 Enable DRP clock */
+    iowrite32(SET_STPC_CLKGEN_CTRL, drp_base_addr + STPC_CLKGEN_CTRL);
+
+    /* DRP Init operation: No.2 Release the DRPCLKGEN module reset */
+    iowrite32(SET_STPC_CLKGEN_RST, drp_base_addr + STPC_CLKGEN_RST);
+
+    /* DRP Init operation: No.3 Shift to standby mode */
+    iowrite32(SET_STPC_CLKGEN_STBYWAIT_EN, drp_base_addr + STPC_CLKGEN_STBYWAIT);
+
+    /* DRP Init operation: No.4 DRP clock operating frequency setting */
+    /* Div divided by 4 (DCLK=315MHz), set to dynamic frequency mode */
+    /* Div divided by 4 (DCLK=315MHz) -> When Config is loaded       */
+    /* Dynamic frequency mode -> When DRP application is running     */
+    iowrite32(SET_STPC_CLKGEN_DIV, drp_base_addr + STPC_CLKGEN_DIV);
+    iowrite32(SET_STPC_CLKGEN_STBYWAIT_DI, drp_base_addr + STPC_CLKGEN_STBYWAIT);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+
+static int32_t drp_init_bottomhalf(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret;
+    uint32_t loop;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* DRP Init operation: No.7 Data input channel settings */
+    iowrite32(SET_IDMACIF_DSC_EN,  drp_base_addr + IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + IDIF_DMACTLI1);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + IDIF_DMACTLI2);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + IDIF_DMACTLI3);
+
+    /* DRP Init operation: No.8 Data output channel settings */
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO0);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO1);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO2);
+    iowrite32(SET_IDMACIF_MEMR_EN, drp_base_addr + ODIF_DMACTLO3);
+
+    /* DRP Init operation: No.9 Write Configuration */
+    iowrite32(SET_IDMACIF_DSC_EN, drp_base_addr + IDIF_DMACTLCW);
+
+    /* Unmasks ODMAC interrupts */
+    iowrite32(0xFFFFFFF0, drp_base_addr + ODIF_INTMSK);
+
+    /* DRP error interrupt mask release */
+    for (loop = 0; loop < DRP_ERRINT_MSK_REG_NUM; loop++)
+    {
+        iowrite32(drp_errint_msk_reg_tbl[loop][1],
+               drp_base_addr + drp_errint_msk_reg_tbl[loop][0]);
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int32_t drp_start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc)
+{
+    int32_t ret;
+    uint32_t reg_val;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+#if 1 
+    /* Clear interrupt factor */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);
+    iowrite32(reg_val, drp_base_addr + ODIF_INT);            /* Clear */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);            /* Dummy read */
+
+    /* Reading the number of interrupts */
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO0);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO1);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO2);
+    reg_val = ioread32(drp_base_addr + ODIF_INTCNTO3);
+
+    /* Unmasks ODMAC interrupts */
+    iowrite32(0xFFFFFFF0, drp_base_addr + ODIF_INTMSK);
+#endif
+
+    /* Set descriptor start address */
+    iowrite32(desc, drp_base_addr + DSCC_DPA);
+
+    /* Clear prefetch of input descriptor */
+    iowrite32(SET_DSCC_DCTL_CR, drp_base_addr + DSCC_DCTL);
+
+    /* Start prefetch of input descriptor */
+    iowrite32(SET_DSCC_DCTL, drp_base_addr + DSCC_DCTL);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int32_t aimac_init(void __iomem *aimac_base_addr, int32_t ch)
+{
+    int32_t ret;
+    uint32_t loop;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (AIMAC_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* Unreset MCLKGEN module */
+    iowrite32(SET_EXD0_STPC_CLKGEN_RST, aimac_base_addr + EXD0_STPC_CLKGEN_RST);
+
+    /* Shift to standby mode */
+    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_EN, aimac_base_addr + EXD0_STPC_CLKGEN_STBYWAIT);
+
+    /* AIMAC clock operating frequency setting */
+    /* Div divided by 2 (MCLK=630MHz), set to fixed frequency mode */
+    iowrite32(SET_EXD0_STPC_CLKGEN_DIV, aimac_base_addr + EXD0_STPC_CLKGEN_DIV);
+
+    /* Clock activation */
+    iowrite32(SET_EXD0_STPC_CLKGEN_STBYWAI_DI, aimac_base_addr + EXD0_STPC_CLKGEN_STBYWAIT);
+
+    /* Enable Clock */
+    iowrite32(SET_EXDX_STPC_CLKE_EN, aimac_base_addr + EXD0_STPC_CLKE);
+    iowrite32(SET_EXDX_STPC_CLKE_EN, aimac_base_addr + EXD1_STPC_CLKE);
+    iowrite32(SET_CLKRSTCON_CLKE_EN, aimac_base_addr + CLKRSTCON_CLKE);
+
+    /* Release soft reset */
+    iowrite32(SET_EXDX_STPC_SFTRST_DI, aimac_base_addr + EXD0_STPC_SFTRST);
+    iowrite32(SET_EXDX_STPC_SFTRST_DI, aimac_base_addr + EXD1_STPC_SFTRST);
+    iowrite32(SET_CLKRSTCON_SFTRST_DI, aimac_base_addr + CLKRSTCON_SFTRST);
+
+    /* DMA channel settings */
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_IDIF_DMACTLI3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD0_ODIF_DMACTLO3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_IDIF_DMACTLI3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO0);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO1);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO2);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + EXD1_ODIF_DMACTLO3);
+    iowrite32(SET_IDMACIF_MEMR_EN, aimac_base_addr + AID_IDIF_DMACTLI0);
+
+    /* DRP-AI processing completion interrupt mask release */
+    iowrite32(SET_EXD1_ODIF_INTMSK, aimac_base_addr + EXD1_ODIF_INTMSK);
+
+    /* AI-MAC error interrupt mask release */
+    for (loop = 0; loop < AIMAC_ERRINT_MSK_REG_NUM; loop++)
+    {
+        iowrite32(aimac_errint_msk_reg_tbl[loop][1],
+               aimac_base_addr + aimac_errint_msk_reg_tbl[loop][0]);
+    }
+
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int32_t aimac_start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock)
+{
+    int32_t ret;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (AIMAC_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* Initialization of register value storage variable */
+    spin_lock_irqsave(lock, flags);
+    exd0_odif_int_val = 0;
+    spin_unlock_irqrestore(lock, flags);
+
+    /* Set the start address of AIMAC descriptor */
+    iowrite32(desc, aimac_base_addr + AID_DSCC_DPA);
+
+    /* Start descriptor read */
+    iowrite32(SET_AID_DSCC_DCTL_CR, aimac_base_addr + AID_DSCC_DCTL);
+    iowrite32(SET_AID_DSCC_DCTL, aimac_base_addr + AID_DSCC_DCTL);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPAI_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    ret = drp_init_tophalf(drp_base_addr, ch, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    /* DRP Init operation: No.5 Enable DRPA DMA channel clock */
+    iowrite32(SET_STPC_CLKE_EN, drp_base_addr + STPC_CLKE);
+    /* DRP Init operation: No.6 Release DRPA Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(SET_STPC_SFTRST_DI, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
+
+    ret = drp_init_bottomhalf(drp_base_addr, ch, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPB_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    ret = drp_init_tophalf(drp_base_addr, ch, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    /* DRP Init operation: No.5 Enable DRPB DMA channel clock */
+    iowrite32(SET_DRPB_STPC_CLKE_EN, drp_base_addr + STPC_CLKE);
+    /* DRP Init operation: No.6 Release DRPB Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(SET_DRPB_STPC_SFTRST_DI, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
+
+    ret = drp_init_bottomhalf(drp_base_addr, ch, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPAI_DRP_Start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    ret = drp_start(drp_base_addr, ch, desc);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPB_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    
+    drp_nmlint(drp_base_addr, odif_intcnto);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPAI_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    
+    drp_nmlint(drp_base_addr, odif_intcnto);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPB_DRP_Errint(void __iomem *drp_base_addr, int32_t ch)
+{
+    uint32_t reg_val;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    printk(KERN_ERR "DRP ERROR\n");
+
+    /* Show descriptor pointer */
+    reg_val = ioread32(drp_base_addr + DSCC_PAMON);
+    printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
+
+    drp_errint(drp_base_addr);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPAI_DRP_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch)
+{
+    uint32_t reg_val;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    printk(KERN_ERR "DRP-AI DRP ERROR\n");
+
+    /* Show descriptor pointer */
+    reg_val = ioread32(drp_base_addr + DSCC_PAMON);
+    printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
+    reg_val = ioread32(aimac_base_addr + AID_DSCC_PAMON);
+    printk(KERN_ERR "AID_DSCC_PAMON  : 0x%08X\n", reg_val);
+
+    drp_errint(drp_base_addr);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPAI_AIMAC_Open(void __iomem *aimac_base_addr, int32_t ch)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (AIMAC_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    ret = aimac_init(aimac_base_addr, ch);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPAI_AIMAC_Start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (AIMAC_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    ret = aimac_start(aimac_base_addr, ch, desc, lock);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPAI_AIMAC_Nmlint(void __iomem *aimac_base_addr, int32_t ch)
+{
+    volatile uint32_t dummy;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Debug information */
+    exd0_odif_int_val = ioread32(aimac_base_addr + EXD1_ODIF_INT);
+
+    /* Clear interrupt factor */
+    iowrite32(0x00000008, aimac_base_addr + EXD1_ODIF_INT);   /* Clear */
+    dummy = ioread32(aimac_base_addr + EXD1_ODIF_INT);        /* Dummy read */
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPAI_AIMAC_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch)
+{
+    uint32_t reg_val;
+    uint8_t i;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    printk(KERN_ERR "DRP-AI AI-MAC ERROR\n");
+
+    /* Show descriptor pointer */
+    reg_val = ioread32(drp_base_addr + DSCC_PAMON);
+    printk(KERN_ERR "DSCC_PAMON      : 0x%08X\n", reg_val);
+    reg_val = ioread32(aimac_base_addr + AID_DSCC_PAMON);
+    printk(KERN_ERR "AID_DSCC_PAMON  : 0x%08X\n", reg_val);
+
+    /* Error interrupt cause register */
+    intmon_errint_val = ioread32(aimac_base_addr + INTMON_ERRINT);
+    printk(KERN_ERR "INTMON_ERRINT : 0x%08X\n", intmon_errint_val);
+
+    for (i = 0; i < AIMAC_ERRINT_STATUS_REG_NUM; i++)
+    {
+        reg_val = ioread32(aimac_base_addr + aimac_errint_status_reg_tbl[i]);
+        iowrite32(reg_val, aimac_base_addr + aimac_errint_status_reg_tbl[i]);
+        printk(KERN_ERR "%s : 0x%08X\n",aimac_errint_status_reg_name_tbl[i], reg_val);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+int32_t R_DRPAI_Status(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, drpai_status_t *drpai_status)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+    if (AIMAC_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* DRP Address of descriptor */
+    drpai_status->reserved[DRPAI_RESERVED_DSCC_PAMON] = ioread32(drp_base_addr + DSCC_PAMON);
+
+    /* AI-MAC Address of descriptor */
+    drpai_status->reserved[DRPAI_RESERVED_AID_DSCC_PAMON] = ioread32(aimac_base_addr + AID_DSCC_PAMON);
+
+    /* DRP-AI processing complete interrupt status */
+    drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_IRQ] = exd0_odif_int_val;
+    drpai_status->reserved[DRPAI_RESERVED_EXD1_ODIF_INT_NOW] = ioread32(aimac_base_addr + EXD1_ODIF_INT);
+
+    /* AI-MAC synchronization information */
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL12] = ioread32(aimac_base_addr + SYNCTBL_TBL12);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL13] = ioread32(aimac_base_addr + SYNCTBL_TBL13);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL14] = ioread32(aimac_base_addr + SYNCTBL_TBL14);
+    drpai_status->reserved[DRPAI_RESERVED_SYNCTBL_TBL15] = ioread32(aimac_base_addr + SYNCTBL_TBL15);
+
+    /* DRP error information */
+    drpai_status->reserved[DRPAI_RESERVED_STPC_ERRINT_STS] = stpc_errint_sts_val;
+
+    /* AI-MAC error information */
+    drpai_status->reserved[DRPAI_RESERVED_INTMON_ERRINT] = intmon_errint_val;
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPB_Status(void __iomem *drp_base_addr, int32_t ch, drpai_status_t *drpai_status)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* DRP Address of descriptor */
+    drpai_status->reserved[DRPAI_RESERVED_DSCC_PAMON] = ioread32(drp_base_addr + DSCC_PAMON);
+
+    /* DRP error information */
+    drpai_status->reserved[DRPAI_RESERVED_STPC_ERRINT_STS] = stpc_errint_sts_val;
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static void reg_bit_clear(volatile void __iomem *reg_address, uint32_t bit)
+{
+    uint32_t tmp_reg;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Read register value */
+    tmp_reg = ioread32(reg_address);
+    /* Clear the target bit */
+    tmp_reg = tmp_reg & (~bit);
+
+    iowrite32(tmp_reg, reg_address);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void aimac_clear_synctbl_tbl(void __iomem *aimac_base_addr)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL0);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL1);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL2);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL3);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL4);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL5);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL6);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL7);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL8);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL9);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL10);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL11);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL12);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL13);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL14);
+    iowrite32(0x0000FFFF, aimac_base_addr + SYNCTBL_TBL15);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drp_clear_synctbl_tbl(void __iomem *drp_base_addr)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL0);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL1);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL2);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL3);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL4);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL5);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL6);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL7);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL8);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL9);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL10);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL11);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL12);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL13);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL14);
+    iowrite32(0x0000FFFF, drp_base_addr + DRP_SYNCTBL_TBL15);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drp_nmlint(void __iomem *drp_base_addr, drpai_odif_intcnto_t *odif_intcnto)
+{
+    uint32_t reg_val;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Clear interrupt factor */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);
+    iowrite32(reg_val, drp_base_addr + ODIF_INT);         /* Clear */
+    reg_val = ioread32(drp_base_addr + ODIF_INT);         /* Dummy read */
+
+    /* Reading the number of interrupts */
+    odif_intcnto->ch0 = ioread32(drp_base_addr + ODIF_INTCNTO0);
+    odif_intcnto->ch1 = ioread32(drp_base_addr + ODIF_INTCNTO1);
+    odif_intcnto->ch2 = ioread32(drp_base_addr + ODIF_INTCNTO2);
+    odif_intcnto->ch3 = ioread32(drp_base_addr + ODIF_INTCNTO3);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drp_errint(void __iomem *drp_base_addr)
+{
+    uint32_t reg_val;
+    uint32_t loop;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Error interrupt cause register */
+    stpc_errint_sts_val = ioread32(drp_base_addr + STPC_ERRINT_STS);
+    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts_val);
+
+    /* Error display of each module */
+    reg_val = ioread32(drp_base_addr + DRP_ERRINTSTATUS);
+    printk(KERN_ERR "DRP_ERRINTSTATUS : 0x%08X\n", reg_val);
+    if (0 != reg_val)
+    {
+        reg_val = ioread32(drp_base_addr + STPC_SFTRST);
+        reg_val |= DRPAI_BIT31;
+        iowrite32(reg_val, drp_base_addr + STPC_SFTRST);
+    }
+    for (loop = 0; loop < DRP_ERRINT_STATUS_REG_NUM; loop++)
+    {
+        reg_val = ioread32(drp_base_addr + drp_errint_status_reg_tbl[loop]);
+        iowrite32(reg_val, drp_base_addr + drp_errint_status_reg_tbl[loop]);
+        printk(KERN_ERR "%s : 0x%08X\n", drp_errint_status_reg_name_tbl[loop], reg_val);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static int8_t check_dma_reg_stop(void __iomem *base, uint32_t offset)
+{
+    uint32_t reg_val;
+    int8_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    reg_val = ioread32(base + offset);
+    if(!((0 == (reg_val & DRPAI_BIT1)) || (DRPAI_BIT19 == (reg_val & DRPAI_BIT19))))
+    {
+        ret = -1;
+    }
+    else
+    {
+        ret = 0;
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int8_t check_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset)
+{
+    int32_t i;
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    for(i = 0; i < num_offset; i++)
+    {
+        if(0 != check_dma_reg_stop(base, offset[i]))
+        {
+            goto not_stop;
+        }
+        else
+        {
+            ; // Do nothing
+        }
+    }
+
+    ret = 0;
+    goto end;
+not_stop:
+    ret = -1;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+static int8_t wait_for_dma_stop(void __iomem *base, uint32_t *offset, uint32_t num_offset)
+{
+    bool is_stop = false;
+    int8_t ret;
+    int32_t i;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        if(0 != check_dma_stop(base, offset, num_offset))
+        {
+            ; // Do nothing
+        }
+        else
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        if(0 != check_dma_stop(base, offset, num_offset))
+        {
+            ; // Do nothing
+        }
+        else
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(true == is_stop)
+    {
+        ret = 0;
+    }
+    else
+    {
+        ret = -1;
+#ifdef  DRPAI_DRV_DEBUG
+        uint32_t reg_val;
+        for(i = 0; i < num_offset; i++) {
+            reg_val = ioread32(base + offset[i]);
+            DRPAI_DEBUG_PRINT("offset: %08X = 0x%08X\n", offset[i], reg_val);
+        }
+#endif
+    }
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+static int8_t wait_for_desc_prefetch_stop(void __iomem *base, uint32_t offset)
+{
+    bool is_stop = false;
+    int8_t ret;
+    int32_t i;
+    uint32_t reg_val;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        reg_val = ioread32(base + offset);
+        if(0 != (reg_val & DRPAI_BIT1))
+        {
+            ; // Do nothing
+        }
+        else
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        reg_val = ioread32(base + offset);
+        if(0 != (reg_val & DRPAI_BIT1))
+        {
+            ; // Do nothing
+        }
+        else
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(true == is_stop)
+    {
+        ret = 0;
+    }
+    else
+    {
+        ret = -1;
+        DRPAI_DEBUG_PRINT("offset: %08X = 0x%08X\n", offset, reg_val);
+    }
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+int32_t R_DRPAI_DRP_Reset(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret;
+    uint32_t offset_buf[4];
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* Descriptor prefetch stop */
+    reg_bit_clear(drp_base_addr + DSCC_DCTL, DRPAI_BIT0);
+    if(0 != wait_for_desc_prefetch_stop(drp_base_addr, DSCC_DCTL))
+    {
+        goto err_reset;
+    }
+    
+    /* Forced stop of writing configuration data */
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT0);
+    offset_buf[0] = IDIF_DMACTLCW;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 1))
+    {
+        goto err_reset;
+    }
+
+    /* Forced stop of data input / output */
+    /* IDIF_DMACTLI0,I1,I2,I3 */
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT18);
+
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = IDIF_DMACTLI0;
+    offset_buf[1] = IDIF_DMACTLI1;
+    offset_buf[2] = IDIF_DMACTLI2;
+    offset_buf[3] = IDIF_DMACTLI3;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4)){
+        goto err_reset;
+    }
+
+    /* ODIF_DMACTLO0,O1,O2,O3 */
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT18);
+
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = ODIF_DMACTLO0;
+    offset_buf[1] = ODIF_DMACTLO1;
+    offset_buf[2] = ODIF_DMACTLO2;
+    offset_buf[3] = ODIF_DMACTLO3;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* Set DRP core as fixed frequency mode  */
+    iowrite32((SET_STPC_CLKGEN_DIV & 0xFFFFFFFE), drp_base_addr + STPC_CLKGEN_DIV);
+
+    /* Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+err_reset:
+    ret = R_DRPAI_ERR_RESET;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+int32_t R_DRPB_DRP_Reset(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret;
+    uint32_t offset_buf[4];
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* Descriptor prefetch stop */
+    reg_bit_clear(drp_base_addr + DSCC_DCTL, DRPAI_BIT0);
+    if(0 != wait_for_desc_prefetch_stop(drp_base_addr, DSCC_DCTL))
+    {
+        goto err_reset;
+    }
+    
+    /* Forced stop of writing configuration data */
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLCW, DRPAI_BIT0);
+    offset_buf[0] = IDIF_DMACTLCW;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 1))
+    {
+        goto err_reset;
+    }
+
+    /* Forced stop of data input / output */
+    /* IDIF_DMACTLI0,I1,I2,I3 */
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT18);
+
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + IDIF_DMACTLI3, DRPAI_BIT0);
+
+    drp_clear_synctbl_tbl(drp_base_addr);
+
+    offset_buf[0] = IDIF_DMACTLI0;
+    offset_buf[1] = IDIF_DMACTLI1;
+    offset_buf[2] = IDIF_DMACTLI2;
+    offset_buf[3] = IDIF_DMACTLI3;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4)){
+        goto err_reset;
+    }
+
+    /* ODIF_DMACTLO0,O1,O2,O3 */
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT18);
+
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(drp_base_addr + ODIF_DMACTLO3, DRPAI_BIT0);
+
+    drp_clear_synctbl_tbl(drp_base_addr);
+
+    offset_buf[0] = ODIF_DMACTLO0;
+    offset_buf[1] = ODIF_DMACTLO1;
+    offset_buf[2] = ODIF_DMACTLO2;
+    offset_buf[3] = ODIF_DMACTLO3;
+    if(0 != wait_for_dma_stop(drp_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* Set DRP core as fixed frequency mode  */
+    iowrite32((SET_STPC_CLKGEN_DIV & 0xFFFFFFFE), drp_base_addr + STPC_CLKGEN_DIV);
+
+    /* Soft reset */
+    spin_lock_irqsave(lock, flags);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STPC_SFTRST);
+    spin_unlock_irqrestore(lock, flags);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+err_reset:
+    ret = R_DRPAI_ERR_RESET;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+int32_t R_DRPAI_AIMAC_Reset(void __iomem *aimac_base_addr, int32_t ch)
+{
+    int32_t ret;
+    uint32_t offset_buf[4];
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if (DRP_CH_NUM <= ch)
+    {
+        goto err_invalid_arg;
+    }
+
+    /* Descriptor prefetch stop */
+    reg_bit_clear(aimac_base_addr + AID_DSCC_DCTL, DRPAI_BIT0);
+    if(0 != wait_for_desc_prefetch_stop(aimac_base_addr, AID_DSCC_DCTL))
+    {
+        goto err_reset;
+    }
+
+    /* Forced stop of inputting parameters (weights and bias values) */
+    reg_bit_clear(aimac_base_addr + AID_IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + AID_IDIF_DMACTLI0, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = AID_IDIF_DMACTLI0;
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 1))
+    {
+        goto err_reset;
+    }
+
+    /* Forced stop of data input / output */
+    /* EXD0_IDIF_DMACTLI0,I1,I2,I3 */
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI3, DRPAI_BIT18);
+
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_IDIF_DMACTLI3, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = EXD0_IDIF_DMACTLI0;
+    offset_buf[1] = EXD0_IDIF_DMACTLI1;
+    offset_buf[2] = EXD0_IDIF_DMACTLI2;
+    offset_buf[3] = EXD0_IDIF_DMACTLI3;
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* EXD1_IDIF_DMACTLI0,I1,I2,I3 */
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI3, DRPAI_BIT18);
+
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_IDIF_DMACTLI3, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = EXD1_IDIF_DMACTLI0;
+    offset_buf[1] = EXD1_IDIF_DMACTLI1;
+    offset_buf[2] = EXD1_IDIF_DMACTLI2;
+    offset_buf[3] = EXD1_IDIF_DMACTLI3;
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* EXD0_ODIF_DMACTLO0,O1,O2,O3 */
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO3, DRPAI_BIT18);
+
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD0_ODIF_DMACTLO3, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = EXD0_ODIF_DMACTLO0;
+    offset_buf[1] = EXD0_ODIF_DMACTLO1;
+    offset_buf[2] = EXD0_ODIF_DMACTLO2;
+    offset_buf[3] = EXD0_ODIF_DMACTLO3;
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* EXD1_ODIF_DMACTLO0,O1,O2,O3 */
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO0, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO1, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO2, DRPAI_BIT18);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO3, DRPAI_BIT18);
+
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO0, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO1, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO2, DRPAI_BIT0);
+    reg_bit_clear(aimac_base_addr + EXD1_ODIF_DMACTLO3, DRPAI_BIT0);
+
+    aimac_clear_synctbl_tbl(aimac_base_addr);
+
+    offset_buf[0] = EXD1_ODIF_DMACTLO0;
+    offset_buf[1] = EXD1_ODIF_DMACTLO1;
+    offset_buf[2] = EXD1_ODIF_DMACTLO2;
+    offset_buf[3] = EXD1_ODIF_DMACTLO3;
+    if(0 != wait_for_dma_stop(aimac_base_addr, offset_buf, 4))
+    {
+        goto err_reset;
+    }
+
+    /* Soft reset */
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD0_STPC_SFTRST);
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD1_STPC_SFTRST);
+    iowrite32(0x0000001F, aimac_base_addr + CLKRSTCON_SFTRST);
+
+    /* Stop clock */
+    iowrite32(0x00000000, aimac_base_addr + EXD0_STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + EXD1_STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + CLKRSTCON_CLKE);
+
+    /* Stop MCLKGEN */
+    iowrite32(0x00000001, aimac_base_addr + EXD0_STPC_CLKGEN_STBYWAIT);
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+
+err_invalid_arg:
+    ret = R_DRPAI_ERR_INVALID_ARG;
+    goto end;
+err_reset:
+    ret = R_DRPAI_ERR_RESET;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+int32_t R_DRPAI_CPG_Reset(struct reset_control *rst_ctrl)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    ret = drp_cpg_reset(rst_ctrl);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+int32_t R_DRPB_CPG_Reset(struct reset_control *rst_ctrl)
+{
+    int32_t ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    ret = drp_cpg_reset(rst_ctrl);
+    if (R_DRPAI_SUCCESS != ret)
+    {
+        return ret;
+    }
+
+    ret =  R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int32_t drp_cpg_reset(struct reset_control *rst_ctrl)
+{
+    int32_t ret;
+    int32_t i = 0;
+    int r_data;
+    bool is_stop = false;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Access reset controller interface */
+    reset_control_reset(rst_ctrl);
+
+    /* Check reset status */
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        r_data = reset_control_status(rst_ctrl);
+        DRPAI_DEBUG_PRINT("drp reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        r_data = reset_control_status(rst_ctrl);
+        DRPAI_DEBUG_PRINT("drp reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(true == is_stop)
+    {
+        ret =  R_DRPAI_SUCCESS;
+    }
+    else
+    {
+        ret = R_DRPAI_ERR_RESET;
+        DRPAI_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return ret;
+}
+
+#if defined(CONFIG_ARCH_R9A09G011GBG) 
+/* V2M conditional compilation */
+MODULE_DESCRIPTION("RZ/V2M DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2MA conditional compilation */
+MODULE_DESCRIPTION("RZ/V2MA DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+MODULE_DESCRIPTION("RZ/V2L DRPAI driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/drpai/drpai-core.h b/drivers/drpai/drpai-core.h
new file mode 100755
index 000000000000..76ec345245ed
--- /dev/null
+++ b/drivers/drpai/drpai-core.h
@@ -0,0 +1,86 @@
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef R_DRPAI_CORE_H
+#define R_DRPAI_CORE_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <asm/current.h>
+#else /* __KERNEL__ */
+#include "r_typedefs.h"
+#endif /* __KERNEL__ */
+
+#define CH0                             (0)
+#define CH1                             (1)
+#define CH2                             (2)
+#define CH3                             (3)
+#define DRP_CH_NUM                      (1)
+#define AIMAC_CH_NUM                    (1)
+#define MAC256_CH_NUM                   (4)
+
+/* Error code */
+#define R_DRPAI_SUCCESS                 (0)
+#define R_DRPAI_ERR_INVALID_ARG         (-1)
+#define R_DRPAI_ERR_RESET               (-2)
+
+#define DEVICE_RZV2M                    (0)
+#define DEVICE_RZV2MA                   (1)
+#define DEVICE_RZV2L                    (2)
+
+#define CPG_RESET_SUCCESS               (0)
+
+#define RST_CPG_WAIT (10)
+#define RST_MAX_TIMEOUT (100)
+
+/* Debug macro */
+// #define   DRPAI_DRV_DEBUG
+#ifdef  DRPAI_DRV_DEBUG
+#define DRPAI_DEBUG_PRINT(fmt, ...) \
+            pr_info("[%s: %d](pid: %d) "fmt, \
+                            __func__, __LINE__, current->pid, ##__VA_ARGS__)
+#else
+#define DRPAI_DEBUG_PRINT(...)
+#endif
+
+typedef struct drpai_odif_intcnto
+{
+    uint32_t    ch0;
+    uint32_t    ch1;
+    uint32_t    ch2;
+    uint32_t    ch3;
+} drpai_odif_intcnto_t;
+
+int32_t R_DRPAI_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPAI_DRP_Start(void __iomem *drp_base_addr, int32_t ch, uint32_t desc);
+int32_t R_DRPAI_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto);
+int32_t R_DRPAI_DRP_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Open(void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Start(void __iomem *aimac_base_addr, int32_t ch, uint32_t desc, spinlock_t *lock);
+int32_t R_DRPAI_AIMAC_Nmlint(void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_AIMAC_Errint(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_Status(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, drpai_status_t *drpai_status);
+int32_t R_DRPAI_DRP_Reset(void __iomem *drp_base_addr, void __iomem *aimac_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPAI_AIMAC_Reset(void __iomem *aimac_base_addr, int32_t ch);
+int32_t R_DRPAI_CPG_Reset(struct reset_control *rst_ctrl);
+int32_t R_DRPB_DRP_Open(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPB_Status(void __iomem *drp_base_addr, int32_t ch, drpai_status_t *drpai_status);
+int32_t R_DRPB_DRP_Reset(void __iomem *drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRPB_CPG_Reset(struct reset_control *rst_ctrl);
+int32_t R_DRPB_DRP_Nmlint(void __iomem *drp_base_addr, int32_t ch, drpai_odif_intcnto_t *odif_intcnto);
+int32_t R_DRPB_DRP_Errint(void __iomem *drp_base_addr, int32_t ch);
+
+#endif /* R_DRPAI_CORE_H */
diff --git a/drivers/drpai/drpai-if.c b/drivers/drpai/drpai-if.c
new file mode 100755
index 000000000000..f251f9f56461
--- /dev/null
+++ b/drivers/drpai/drpai-if.c
@@ -0,0 +1,3657 @@
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/cacheflush.h>
+#include <asm/current.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/buffer_head.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/drpai.h>    /* Header file for DRP-AI Driver */
+#include "drpai-core.h"     /* Header file for DRP-AI Core */
+
+// #define DRPAI_DRV_DEBUG_WAIT
+#ifdef DRPAI_DRV_DEBUG_WAIT
+#define DRPAI_DEBUG_WAIT(...) msleep(1100);
+#else
+#define DRPAI_DEBUG_WAIT(...)
+#endif
+
+#ifdef DRPAI_DRV_DEBUG
+#define DRPAI_DRV_DEBUG_MODE        " (Debug Mode ON)"
+#else
+#define DRPAI_DRV_DEBUG_MODE        ""
+#endif
+
+#ifdef DRPAI_DRV_DEBUG_WAIT
+#define DRPAI_DRV_DEBUG_WAIT_MODE   " (Debug Wait Mode ON)"
+#else
+#define DRPAI_DRV_DEBUG_WAIT_MODE   ""
+#endif
+
+/*Macro definitions*/
+#define DRPAI_DRIVER_VERSION        "2.10 rel.1"
+#define DRPAI_DEV_NUM               (1)
+#define DRPAI_DRIVER_NAME           "drpai"     /* Device name */
+#define DRPAI_64BYTE_ALIGN          (0x3F)      /* Check 64-byte alignment */
+
+#define DRPAI_STATUS_IDLE_RW        (10)
+#define DRPAI_STATUS_ASSIGN         (11)
+#define DRPAI_STATUS_DUMP_REG       (12)
+#define DRPAI_STATUS_READ_MEM       (13)
+#define DRPAI_STATUS_READ_REG       (14)
+#define DRPAI_STATUS_WRITE          (15)
+#define DRPAI_STATUS_ASSIGN_PARAM   (16)
+#define DRPAI_STATUS_WRITE_PARAM    (17)
+#define DRPAI_STATUS_ASSIGN_DYNAMIC (18)
+#define DRPAI_STATUS_WRITE_DYNAMIC  (19)
+
+#define MAX_SEM_TIMEOUT             (msecs_to_jiffies(1000))
+#define HEAD_SENTINEL               (UINT_MAX)
+
+#define DRP_DESC_ENTRY_SIZE         (16)
+#define DRP_DESC_TYPE_INDEX         (3)
+#define DRP_DESC_TYPE_RSHIFT        (3)
+#define DRP_DESC_TYPE_MASK          (0x01)
+#define DRP_DESC_CF_INDEX           (3)
+#define DRP_DESC_CF_RSHIFT          (4)
+#define DRP_DESC_CF_MASK            (0x0F)
+#define DRP_DESC_MOD_INDEX          (1)
+#define DRP_DESC_MOD_RSHIFT         (6)
+#define DRP_DESC_MOD_MASK           (0x03)
+#define DRP_DESC_FUNC_INDEX         (1)
+#define DRP_DESC_FUNC_RSHIFT        (2)
+#define DRP_DESC_FUNC_MASK          (0x01)
+#define DRP_DESC_CF_DRP_DMA         (0)
+#define DRP_DESC_CF_AIMAC_DMA0      (8)
+#define DRP_DESC_CF_AIMAC_DMA1      (9)
+#define DRP_DESC_CF_AIMAC_DMA2      (12)
+#define DRP_DESC_CF_AIMAC_DMA3      (13)
+#define DRP_DESC_CF_AIMAC_PARAM     (5)
+#define DRP_DESC_CF_CFG_LOAD        (1)
+#define DRP_DESC_ADDR_INDEX         (4)
+
+#define DRP_PARAM_raddr             (0)
+#define DRP_PARAM_waddr             (4)
+#define DRP_PARAM_IMG_IWIDTH        (8)
+#define DRP_PARAM_IMG_IHEIGHT       (10)
+#define DRP_PARAM_IMG_OWIDTH        (16)
+#define DRP_PARAM_IMG_OHEIGHT       (18)
+#define DRP_PARAM_CROP_POS_X        (48)
+#define DRP_PARAM_CROP_POS_Y        (50)
+#define DRP_LIB_NAME_CROP           (",drp_lib:crop,")
+#define DRP_PARAM_ATTR_OFFSET_ADD   ("OFFSET_ADD:")
+#define DRP_PARAM_ATTR_PROP_INPUT   (",prop:input,")
+#define DRP_PARAM_ATTR_PROP_OUTPUT  (",prop:output,")
+#define DRP_PARAM_ATTR_PARAM        ("Param:")
+#define DRP_PARAM_ATTR_OFFSET       ("offset:")
+#define DRP_PARAM_NAME_RADDR        ("raddr")
+#define DRP_PARAM_NAME_WADDR        ("waddr")
+#define DRP_PARAM_NAME_ADDR         ("_ADDR")
+
+#define SYS_SIZE                    (1024)
+#define SYS_DRP_BANK                (0x38)
+#define SYS_MASK_DRP                (0x000000C0)
+#define SYS_SHIFT                   (26)
+
+#define IRQ_CHECK_ENABLE            (1)
+#define IRQ_CHECK_DISABLE           (0)
+
+#define ISP_FINISH_SUCCESS          (0)
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+#define DRPAI_SGL_DRP_DESC_SIZE     (80)
+#define DRPAI_DESC_CMD_SIZE         (16)
+#define DRPAI_CMA_SIZE              ((DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM) + DRPAI_DESC_CMD_SIZE + 64)
+#endif /* CONFIG_ARCH_R9A07G054  */
+
+/* A function called from the kernel */
+static int drpai_probe(struct platform_device *pdev);
+static int drpai_remove(struct platform_device *pdev);
+static int drpai_open(struct inode *inode, struct file *file);
+static int drpai_close(struct inode *inode, struct file *file);
+static int drpai_flush(struct file *file, fl_owner_t id);
+static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static ssize_t  drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+static unsigned int drpai_poll( struct file* filp, poll_table* wait );
+static irqreturn_t irq_drp_errint(int irq, void *dev);
+static irqreturn_t irq_mac_nmlint(int irq, void *dev);
+static irqreturn_t irq_mac_errint(int irq, void *dev);
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+static irqreturn_t irq_drp_nmlint(int irq, void *dev);
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+/* Internal function */
+static int drpai_regist_driver(void);
+static int drpai_regist_device(struct platform_device *pdev);
+static void drpai_unregist_driver(void);
+static void drpai_unregist_device(void);
+static void drpai_init_device(uint32_t ch);
+static int8_t drpai_reset_device(uint32_t ch);
+static ssize_t drpai_write_dynamic(struct file *filp, uint8_t *pvirt);
+static ssize_t drpai_write_dynamic_desc(struct file *filp, uint8_t *pvirt);
+static ssize_t drpai_write_dynamic_param(struct file *filp, uint8_t *pvirt);
+static void drpai_rewrite_address(uint8_t *entry, uint32_t addr);
+static struct param_info_list* param_info_list_push(struct param_info_list **pptop, struct param_info_list *pcur, uint32_t offset);
+static void param_info_list_clear(struct param_info_list *ptop);
+static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_assign_dynamic(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drpai_ioctl_get_drpai_area(struct file *filp, unsigned int cmd, unsigned long arg);
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+static long drpai_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif /* CONFIG_ARCH_R9A07G054 */
+static char *get_param_attr(char *line, char *attr, unsigned long *rvalue, char **str);
+static int8_t drp_param_change16(uint64_t base, uint64_t offset, uint16_t value);
+static int8_t drp_param_change32(uint64_t base, uint64_t offset, uint32_t value);
+static int8_t drpai_flush_dcache_input_area(uint64_t addr, uint64_t size);
+static int drpai_drp_cpg_init(void);
+static int8_t drpai_get_sys_bank(uint64_t *bank);
+static int drpai_open_process(void);
+static int drpai_close_process(void);
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* DRP init function for V2L simple ISP */
+static int drpai_drp_config_init(void);
+static void drpai_drp_config_uninit(void);
+
+/* Function called from the kernel for V2L simple ISP */
+int drpai_open_k(void);
+int drpai_close_k(void);
+int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result));
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+/* Linux device driver initialization */
+static const unsigned int MINOR_BASE = 0;
+static const unsigned int MINOR_NUM  = DRPAI_DEV_NUM;       /* Minor number */
+static unsigned int drpai_major;                    /* Major number (decided dinamically) */
+static struct cdev drpai_cdev;                      /* Character device object */
+static struct class *drpai_class = NULL;            /* class object */
+struct device *drpai_device_array[DRPAI_DEV_NUM];
+
+/* Type definitions */
+struct drpai_priv 
+{
+    struct platform_device *pdev;
+    const char *dev_name;
+    uint8_t dev_tag;
+    drpai_status_t drpai_status;
+    spinlock_t lock;
+    struct semaphore sem;
+    refcount_t count;
+    void __iomem *drp_base;
+    void __iomem *aimac_base;
+    uint64_t bank;
+    struct reset_control *rstc;
+    uint32_t irq_flag;
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* V2L ISP */
+    struct clk *clk_int;
+    struct clk *clk_aclk_drp;
+    struct clk *clk_mclk;
+    struct clk *clk_dclkin;
+    struct clk *clk_aclk;
+    void (*isp_finish_loc)(int);
+#endif /* CONFIG_ARCH_R9A07G054 */
+};
+
+static DECLARE_WAIT_QUEUE_HEAD(drpai_waitq);
+
+static struct drpai_priv *drpai_priv;
+
+struct drpai_rw_status 
+{
+    uint32_t rw_status;
+    uint32_t read_count;
+    uint32_t write_count;
+    uint32_t drp_reg_offset_count;
+    uint32_t aimac_reg_offset_count;
+    drpai_data_t drpai_data;
+    drpai_data_dynamic_t drpai_data_dynamic;
+    struct list_head list;
+    drpai_assign_param_t assign_param;
+    char *param_info;
+    atomic_t inout_flag;
+};
+
+struct param_info_list
+{
+    uint32_t offset;
+    struct param_info_list *next;
+};
+
+static DEFINE_SEMAPHORE(rw_sem);
+static struct drpai_rw_status *drpai_rw_sentinel;
+
+/* Virtual base address of register */
+static void __iomem *drp_base_addr[DRP_CH_NUM];
+static void __iomem *aimac_base_address[AIMAC_CH_NUM];
+static resource_size_t drp_size;
+static resource_size_t aimac_size;
+static resource_size_t drpai_region_base_addr;
+static resource_size_t drpai_region_size;
+static resource_size_t drpai_linux_mem_start;
+static resource_size_t drpai_linux_mem_size;
+static resource_size_t sysctrl_region_base_addr;
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* ISP */
+static char* p_dmabuf_vaddr;
+static dma_addr_t p_dmabuf_phyaddr;
+static unsigned char drp_single_desc_bin[] =
+{
+  0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x80, 0x00, 0x01, 0x00, 0x91, 0x81, 0x50, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x07, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x80, 0x00, 0x01, 0x00, 0x91, 0x81, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static drpai_seq_t seq;
+drpai_odif_intcnto_t odif_intcnto;
+static uint32_t exe_mode;
+/* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+/* handler table */
+static struct file_operations s_mydevice_fops = 
+{
+    .open           = drpai_open,
+    .release        = drpai_close,
+    .write          = drpai_write,
+    .read           = drpai_read,
+    .unlocked_ioctl = drpai_ioctl,
+    .compat_ioctl   = drpai_ioctl, /* for 32-bit App */
+    .poll           = drpai_poll,
+    .flush          = drpai_flush,
+};
+
+static const struct of_device_id drpai_match[] = 
+{
+    { .compatible = "renesas,rzv2ma-drpai",},
+    { .compatible = "renesas,rzv2m-drpai", },
+    { .compatible = "renesas,rzv2l-drpai", },
+    { /* sentinel */ }
+};
+
+static struct platform_driver drpai_platform_driver = 
+{
+    .driver = {
+        .name   = "drpai-rz",
+        .of_match_table = drpai_match,
+    },
+    .probe      = drpai_probe,
+    .remove     = drpai_remove,
+};
+
+static int drpai_probe(struct platform_device *pdev)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    drpai_regist_driver();
+    drpai_regist_device(pdev);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static int drpai_remove(struct platform_device *pdev)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    drpai_unregist_driver();
+    drpai_unregist_device();
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static int drpai_open(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("major %d minor %d\n", imajor(inode), iminor(inode));
+
+    /* Allocate drpai_rw_status to each file descriptor */
+    drpai_rw_status = kzalloc(sizeof(struct drpai_rw_status), GFP_KERNEL);
+    if (!drpai_rw_status) 
+    {
+        result = -ENOMEM;
+        goto end;
+    }
+    /* Initialization flag */
+    drpai_rw_status->rw_status  = DRPAI_STATUS_IDLE_RW;
+    drpai_rw_status->param_info = NULL;
+    INIT_LIST_HEAD(&drpai_rw_status->list);
+    atomic_set(&drpai_rw_status->inout_flag, 0);
+    DRPAI_DEBUG_PRINT("Generated list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    file->private_data = drpai_rw_status;
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    if(1 == refcount_read(&priv->count))
+    {
+        result = drpai_open_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            goto end;
+        }
+    }
+    /* Increment reference count */
+    refcount_inc(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    result = 0;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if((-ENOMEM != result) || (-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    }
+    if((0 != drpai_rw_status) && (0 != result))
+    {
+        kfree(file->private_data);
+        file->private_data = NULL;
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int drpai_close(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = file->private_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("major %d minor %d\n", imajor(inode), iminor(inode));
+
+    if(unlikely(down_interruptible(&rw_sem))) 
+    {
+        /* Note: this errno won't be returned to user*/
+        result = -ERESTART;
+        DRPAI_DEBUG_PRINT("R/W semaphore obtained failed\n");
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("HEAD  list %px rw_status %d prev %px next %px\n", &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+    if(!list_empty(&drpai_rw_sentinel->list))
+    {
+        if((DRPAI_STATUS_ASSIGN         == drpai_rw_status->rw_status) ||
+           (DRPAI_STATUS_ASSIGN_DYNAMIC == drpai_rw_status->rw_status) ||
+           (DRPAI_STATUS_READ_MEM       == drpai_rw_status->rw_status) ||
+           (DRPAI_STATUS_WRITE          == drpai_rw_status->rw_status) ||
+           (DRPAI_STATUS_WRITE_DYNAMIC  == drpai_rw_status->rw_status))
+           {
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+           }
+    }
+    up(&rw_sem);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        /* Note: this errno won't be returned to user*/
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("API semaphore obtained failed\n");
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    if(2 == refcount_read(&priv->count))
+    {
+        result = drpai_close_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            DRPAI_DEBUG_PRINT("Reset failed\n");
+        }
+    }
+    /* Decrement referenece count */
+    refcount_dec(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if((-ERESTART != result) || (-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    }
+    /* Free memory */
+    if(NULL != drpai_rw_status->param_info)
+    {
+        DRPAI_DEBUG_PRINT("vfree is called\n");
+        vfree(drpai_rw_status->param_info);
+        drpai_rw_status->param_info = NULL;
+    }
+    if(file->private_data) 
+    {
+        DRPAI_DEBUG_PRINT("kfree is called\n");
+        kfree(file->private_data);
+        file->private_data = NULL;
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int drpai_flush(struct file *file, fl_owner_t id)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static ssize_t  drpai_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    volatile void *p_drpai_cma = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint64_t addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check status */
+    if (!((DRPAI_STATUS_ASSIGN         == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_ASSIGN_DYNAMIC == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_WRITE          == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_WRITE_DYNAMIC  == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_ASSIGN_PARAM   == drpai_rw_status->rw_status) ||
+          (DRPAI_STATUS_WRITE_PARAM    == drpai_rw_status->rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_ASSIGN:
+            /* DRPAI_STATUS_ASSIGN -> DRPAI_STATUS_WRITE */
+            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE;
+            break;
+        case DRPAI_STATUS_ASSIGN_DYNAMIC:
+            /* DRPAI_STATUS_ASSIGN_DYNAMIC -> DRPAI_STATUS_WRITE_DYNAMIC */
+            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE_DYNAMIC;
+            break;
+        case DRPAI_STATUS_ASSIGN_PARAM:
+            /* DRPAI_STATUS_ASSIGN_PARAM -> DRPAI_STATUS_WRITE_PARAM */
+            drpai_rw_status->rw_status = DRPAI_STATUS_WRITE_PARAM;
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_WRITE:
+            /* Expand to DRP for CMA */
+            addr = priv->bank | (uint64_t)drpai_rw_status->drpai_data.address;
+            p_drpai_cma = phys_to_virt(addr + (uint64_t)drpai_rw_status->write_count);
+            if (p_drpai_cma == 0)
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            if (drpai_rw_status->drpai_data.size < (drpai_rw_status->write_count + count))
+            {
+                count = drpai_rw_status->drpai_data.size - drpai_rw_status->write_count;
+            }
+            if (copy_from_user((void *)p_drpai_cma, buf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
+
+            /* DRPAI_STATUS_WRITE -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->drpai_data.size <= drpai_rw_status->write_count)
+            {
+                p_drpai_cma = phys_to_virt(addr);
+                if (p_drpai_cma == 0)
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+                __flush_dcache_area((void *)p_drpai_cma, drpai_rw_status->drpai_data.size);
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+                drpai_rw_status->drpai_data.address = 0x0;
+                drpai_rw_status->drpai_data.size    = 0x0;
+            }
+            result = count;
+            break;
+        case DRPAI_STATUS_WRITE_DYNAMIC:
+            /* Expand to DRP for CMA */
+            addr = priv->bank | ((uint64_t)drpai_rw_status->drpai_data_dynamic.start_address + (uint64_t)drpai_rw_status->drpai_data_dynamic.offset);
+            p_drpai_cma = phys_to_virt(addr + (uint64_t)drpai_rw_status->write_count);
+            if (p_drpai_cma == 0)
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            if (drpai_rw_status->drpai_data_dynamic.size < (drpai_rw_status->write_count + count))
+            {
+                count = drpai_rw_status->drpai_data_dynamic.size - drpai_rw_status->write_count;
+            }
+
+            if (copy_from_user((void *)p_drpai_cma, buf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
+
+            /* DRPAI_STATUS_WRITE_DYNAMIC -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->drpai_data_dynamic.size <= drpai_rw_status->write_count)
+            {
+                p_drpai_cma = phys_to_virt(addr);
+                if (p_drpai_cma == 0)
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+
+                result = drpai_write_dynamic(filp, (uint8_t *)p_drpai_cma);
+                if (result < 0)
+                {
+                    goto end;
+                }
+
+                __flush_dcache_area((void *)p_drpai_cma, drpai_rw_status->drpai_data.size);
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+                drpai_rw_status->drpai_data_dynamic.start_address = 0x0;
+                drpai_rw_status->drpai_data_dynamic.offset        = 0x0;
+                drpai_rw_status->drpai_data_dynamic.size          = 0x0;
+                drpai_rw_status->drpai_data_dynamic.file_type     = 0x0;
+            }
+            result = count;
+            break;
+        case DRPAI_STATUS_WRITE_PARAM:
+            if (drpai_rw_status->assign_param.info_size < (drpai_rw_status->write_count + count))
+            {
+                count = drpai_rw_status->assign_param.info_size - drpai_rw_status->write_count;
+            }
+            /* Copy arguments from user space to kernel space */
+            if (copy_from_user(&drpai_rw_status->param_info[drpai_rw_status->write_count], buf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->write_count = drpai_rw_status->write_count + count;
+            /* DRPAI_STATUS_WRITE_PARAM -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->assign_param.info_size <= drpai_rw_status->write_count)
+            {
+                DRPAI_DEBUG_PRINT("Status is changed \n");
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+            }
+            result = count;
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw3:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static ssize_t drpai_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    uint8_t *kbuf = NULL;
+    volatile void *p_drpai_cma = 0;
+    uint32_t reg_val;
+    uint32_t i;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    struct drpai_priv *priv = drpai_priv;
+    uint64_t addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check status */
+    if (!((DRPAI_STATUS_ASSIGN  == drpai_rw_status->rw_status) ||
+        (DRPAI_STATUS_DUMP_REG  == drpai_rw_status->rw_status) ||
+        (DRPAI_STATUS_READ_MEM  == drpai_rw_status->rw_status) ||
+        (DRPAI_STATUS_READ_REG  == drpai_rw_status->rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_ASSIGN:
+            /* DRPAI_STATUS_ASSIGN -> DRPAI_STATUS_READ_MEM */
+            drpai_rw_status->rw_status = DRPAI_STATUS_READ_MEM;
+            break;
+        case DRPAI_STATUS_DUMP_REG:
+            /* DRPAI_STATUS_DUMP_REG -> DRPAI_STATUS_READ_REG */
+            drpai_rw_status->rw_status = DRPAI_STATUS_READ_REG;
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    switch(drpai_rw_status->rw_status)
+    {
+        case DRPAI_STATUS_READ_MEM:
+            /* Read DRP-AI memory */
+            addr = priv->bank | (uint64_t)drpai_rw_status->drpai_data.address;
+            p_drpai_cma = phys_to_virt(addr + drpai_rw_status->read_count);
+            if (p_drpai_cma == 0)
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            if ( !( drpai_rw_status->drpai_data.size >= (drpai_rw_status->read_count + count) ) )
+            {
+                count = drpai_rw_status->drpai_data.size - drpai_rw_status->read_count;
+            }
+            /* Copy arguments from kernel space to user space */
+            if (copy_to_user(buf, (void *)p_drpai_cma, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            drpai_rw_status->read_count = drpai_rw_status->read_count + count;
+
+            /* DRPAI_STATUS_READ -> DRPAI_STATUS_IDLE_RW */
+            if (drpai_rw_status->drpai_data.size <= drpai_rw_status->read_count)
+            {
+                drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                DRPAI_DEBUG_PRINT("Deleted list %px rw_status %d prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->rw_status, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+                list_del(&drpai_rw_status->list);
+                drpai_rw_status->drpai_data.address = 0x0;
+                drpai_rw_status->drpai_data.size    = 0x0;
+            }
+            i = count;
+            break;
+        case DRPAI_STATUS_READ_REG:
+            /* Read DRP-AI register */
+            if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+            {
+                result = -ETIMEDOUT;
+                goto end;
+            }
+            /* Secure Kbuf area */
+            kbuf = vmalloc(count);
+            if (NULL == kbuf)
+            {
+                result = -ENOMEM;
+                goto end;
+            }
+            for (i = 0; i < count; i+=4)
+            {
+                if (drp_size > drpai_rw_status->read_count)
+                {
+                    reg_val = ioread32(drp_base_addr[0] + drpai_rw_status->drp_reg_offset_count);
+                    *(kbuf + i)     = (uint8_t)reg_val;
+                    *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
+                    *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
+                    *(kbuf + i + 3) = (uint8_t)(reg_val >> 24);
+                    drpai_rw_status->drp_reg_offset_count+=4;
+                }
+                else
+                {
+                    reg_val = ioread32(aimac_base_address[0] + drpai_rw_status->aimac_reg_offset_count);
+                    *(kbuf + i)     = (uint8_t)reg_val;
+                    *(kbuf + i + 1) = (uint8_t)(reg_val >> 8);
+                    *(kbuf + i + 2) = (uint8_t)(reg_val >> 16);
+                    *(kbuf + i + 3) = (uint8_t)(reg_val >> 24);
+                    drpai_rw_status->aimac_reg_offset_count+=4;
+                }
+                drpai_rw_status->read_count+=4;
+
+                /* DRPAI_STATUS_READ_REG -> DRPAI_STATUS_IDLE_RW */
+                if ((drp_size + aimac_size) <= drpai_rw_status->read_count)
+                {
+                    drpai_rw_status->rw_status = DRPAI_STATUS_IDLE_RW;
+                    i+=4;
+                    break;
+                }
+            }
+            up(&priv->sem);
+            /* Copy arguments from kernel space to user space */
+            if (copy_to_user(buf, kbuf, count))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            break;
+        default:
+            ; /* Do nothing */
+            break;
+    }
+
+    result = i;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    if (NULL != kbuf)
+    {
+        /* Free kbuf */
+        vfree(kbuf);
+    }
+    DRPAI_DEBUG_PRINT("status_rw3:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+
+    switch (cmd) {
+    case DRPAI_ASSIGN:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN)]\n");
+        result = drpai_ioctl_assign(filp, cmd, arg);
+        break;
+    case DRPAI_START:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_START)]\n");
+        result = drpai_ioctl_start(filp, cmd, arg);
+        break;
+    case DRPAI_RESET:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_RESET)]\n");
+        result = drpai_ioctl_reset(filp, cmd, arg);
+        break;
+    case DRPAI_GET_STATUS:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_GET_STATUS)]\n");
+        result = drpai_ioctl_get_status(filp, cmd, arg);
+        break;
+    case DRPAI_REG_DUMP:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_REG_DUMP)]\n");
+        result = drpai_ioctl_reg_dump(filp, cmd, arg);
+        break;
+    case DRPAI_ASSIGN_PARAM:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN_PARAM)]\n");
+        result = drpai_ioctl_assign_param(filp, cmd, arg);
+        break;
+    case DRPAI_PREPOST_CROP:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_PREPOST_CROP)]\n");
+        result = drpai_ioctl_prepost_crop(filp, cmd, arg);
+        break;
+    case DRPAI_PREPOST_INADDR:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_PREPOST_INADDR)]\n");
+        result = drpai_ioctl_prepost_inaddr(filp, cmd, arg);
+        break;
+    case DRPAI_ASSIGN_DYNAMIC:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_ASSIGN_DYNAMIC)]\n");
+        result = drpai_ioctl_assign_dynamic(filp, cmd, arg);
+        break;
+    case DRPAI_GET_DRPAI_AREA:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_GET_DRPAI_AREA)]\n");
+        result = drpai_ioctl_get_drpai_area(filp, cmd, arg);
+        break;
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    case DRPAI_SET_SEQ:
+        DRPAI_DEBUG_PRINT("[ioctl(DRPAI_SET_SEQ)]\n");
+        result = drpai_ioctl_set_seq(filp, cmd, arg);
+        break;
+#endif /* CONFIG_ARCH_R9A07G054 */
+    default:
+        DRPAI_DEBUG_PRINT(KERN_WARNING "unsupported command %d\n", cmd);
+        result = -EFAULT;
+        break;
+    }
+    goto end;
+
+end:
+    return result;
+}
+
+static unsigned int drpai_poll( struct file* filp, poll_table* wait )
+{
+    unsigned int retmask = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+    poll_wait( filp, &drpai_waitq,  wait );
+
+    if (IRQ_CHECK_DISABLE == priv->irq_flag)
+    {
+        retmask |= ( POLLIN  | POLLRDNORM );
+    }
+
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return retmask;
+}
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+static irqreturn_t irq_drp_nmlint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+    drpai_odif_intcnto_t local_odif_intcnto;
+    void (*finish_callback)(int);
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    /* For success ISP call back*/
+    finish_callback = priv->isp_finish_loc;
+
+    DRPAI_DEBUG_PRINT("\n");
+    DRPAI_DEBUG_PRINT("status1:%d\n", priv->drpai_status.status);
+
+    /* DRP normal interrupt processing */
+    R_DRPAI_DRP_Nmlint(drp_base_addr[0], 0, &local_odif_intcnto);
+
+    odif_intcnto.ch0 += local_odif_intcnto.ch0;
+    odif_intcnto.ch1 += local_odif_intcnto.ch1;
+    odif_intcnto.ch2 += local_odif_intcnto.ch2;
+    odif_intcnto.ch3 += local_odif_intcnto.ch3;
+
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
+
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO0 : 0x%08X\n", local_odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO1 : 0x%08X\n", local_odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO2 : 0x%08X\n", local_odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("local_ODIF_INTCNTO3 : 0x%08X\n", local_odif_intcnto.ch3);
+
+/* DRP single operation */
+    if(DRPAI_EXE_AI == exe_mode)
+    {
+        if  ((1 == odif_intcnto.ch0) &&
+            (1 == odif_intcnto.ch1) &&
+            (1 == odif_intcnto.ch2) &&
+            (1 == odif_intcnto.ch3))
+        {
+            /* Internal state update */
+            priv->drpai_status.status = DRPAI_STATUS_IDLE;
+            DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+            /* For success ISP call back*/
+            if(NULL != finish_callback)
+            {
+                (*finish_callback)(ISP_FINISH_SUCCESS);
+            }
+        }
+    }
+    else if (DRPAI_EXE_DRP == exe_mode)
+    {
+        if ((seq.num == odif_intcnto.ch0) &&
+            (seq.num == odif_intcnto.ch1) &&
+            (seq.num == odif_intcnto.ch2) &&
+            (seq.num == odif_intcnto.ch3))
+        {
+            /* Internal state update */
+            priv->drpai_status.status = DRPAI_STATUS_IDLE;
+            DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+            priv->irq_flag = IRQ_CHECK_DISABLE;
+            /* Wake up the process */
+            wake_up_interruptible( &drpai_waitq );
+        }
+    }
+    else
+    {
+        // do nothing
+    }
+/* DRP single operation */
+
+    priv->isp_finish_loc = NULL;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+static irqreturn_t irq_drp_errint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    void (*finish_callback)(int); /* For error simple ISP call back*/
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    finish_callback = priv->isp_finish_loc;
+
+    if(NULL != finish_callback)
+    {
+        (*finish_callback)(-EIO);
+    }
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* DRP error interrupt processing */
+    R_DRPAI_DRP_Errint(drp_base_addr[0], aimac_base_address[0], 0);
+
+    /* Internal state update */
+    priv->drpai_status.err = DRPAI_ERRINFO_DRP_ERR;
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+#if defined(CONFIG_ARCH_R9A07G054)
+    /* V2L conditional compilation */
+    /* Wake up the process when it's not ISP mode*/
+    if(NULL == finish_callback)
+    {
+        wake_up_interruptible( &drpai_waitq );
+    }
+    priv->isp_finish_loc = NULL;
+#elif defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG)
+    /* V2M(A) conditional compilation */
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+#endif 
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t irq_mac_nmlint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* AI-MAC normal interrupt processing */
+    R_DRPAI_AIMAC_Nmlint(aimac_base_address[0], 0);
+
+    /* Internal state update */
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t irq_mac_errint(int irq, void *dev)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* AI-MAC error interrupt processing */
+    R_DRPAI_AIMAC_Errint(drp_base_addr[0], aimac_base_address[0], 0);
+
+    /* Internal state update */
+    priv->drpai_status.err = DRPAI_ERRINFO_AIMAC_ERR;
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return IRQ_HANDLED;
+}
+
+static int drpai_regist_driver(void)
+{
+    int alloc_ret = 0;
+    int cdev_err = 0;
+    dev_t dev;
+    int minor;
+    int ptr_err;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Get free major number. */
+    alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRPAI_DRIVER_NAME);
+    if (alloc_ret != 0) {
+        pr_err("DRP-AI Driver: alloc_chrdev_region = %d\n", alloc_ret);
+        return -1;
+    }
+
+    /* Save major number. */
+    drpai_major = MAJOR(dev);
+    dev = MKDEV(drpai_major, MINOR_BASE);
+
+    /* Initialize cdev and registration handler table. */
+    cdev_init(&drpai_cdev, &s_mydevice_fops);
+    drpai_cdev.owner = THIS_MODULE;
+
+    /* Registration cdev */
+    cdev_err = cdev_add(&drpai_cdev, dev, MINOR_NUM);
+    if (cdev_err != 0) {
+        pr_err("DRP-AI Driver: cdev_add = %d\n", cdev_err);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -1;
+    }
+
+    /* Cleate class "/sys/class/drpai/" */
+    drpai_class = class_create(THIS_MODULE, DRPAI_DRIVER_NAME);
+    if (IS_ERR(drpai_class)) {
+        ptr_err = PTR_ERR(drpai_class);
+        pr_err("DRP-AI Driver: class_create = %d\n", ptr_err);
+        cdev_del(&drpai_cdev);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -1;
+    }
+
+    /* Make "/sys/class/drpai/drpai*" */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        drpai_device_array[minor - MINOR_BASE] =
+        device_create(drpai_class, NULL, MKDEV(drpai_major, minor), NULL, DRPAI_DRIVER_NAME "%d", minor);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static int drpai_regist_device(struct platform_device *pdev)
+{
+    struct resource *res;
+    struct resource reserved_res;
+    struct device_node *np;
+    struct drpai_priv *priv;
+    struct drpai_rw_status *drpai_rw_status;
+    int irq, ret;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Intialize DRP-AI status to control */
+    priv = devm_kzalloc(&pdev->dev, sizeof(struct drpai_priv), GFP_KERNEL);
+    if (!priv) {
+        dev_err(&pdev->dev, "cannot allocate private data\n");
+        return -ENOMEM;
+    }
+
+    platform_set_drvdata(pdev, priv);
+    priv->pdev = pdev;
+    priv->dev_name = dev_name(&pdev->dev);
+    spin_lock_init(&priv->lock);
+    sema_init(&priv->sem, DRPAI_DEV_NUM);
+    refcount_set(&priv->count, 1);
+    priv->drpai_status.status = DRPAI_STATUS_INIT; 
+    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+    drpai_priv = priv;
+
+    /* Initialize list head */
+    drpai_rw_status = devm_kzalloc(&pdev->dev, sizeof(struct drpai_rw_status), GFP_KERNEL);
+    if (!drpai_rw_status) {
+        dev_err(&pdev->dev, "cannot allocate sentinel data\n");
+        return -ENOMEM;
+    }
+    drpai_rw_status->rw_status  = HEAD_SENTINEL;
+    drpai_rw_status->param_info = NULL;
+    INIT_LIST_HEAD(&drpai_rw_status->list);
+    atomic_set(&drpai_rw_status->inout_flag, 0);
+    drpai_rw_sentinel = drpai_rw_status;
+    DRPAI_DEBUG_PRINT("HEAD  list %px rw_status %d prev %px next %px\n", &drpai_rw_sentinel->list, drpai_rw_sentinel->rw_status, drpai_rw_sentinel->list.prev, drpai_rw_sentinel->list.next);
+
+    if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2m-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2M;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2M\n", DRPAI_DRIVER_VERSION DRPAI_DRV_DEBUG_MODE DRPAI_DRV_DEBUG_WAIT_MODE);
+    }
+    else if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2ma-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2MA;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2MA\n", DRPAI_DRIVER_VERSION DRPAI_DRV_DEBUG_MODE DRPAI_DRV_DEBUG_WAIT_MODE);
+    }
+    else if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2l-drpai"))
+    {
+        drpai_priv->dev_tag = DEVICE_RZV2L;
+        dev_info(&pdev->dev, "DRP-AI Driver version : %s V2L\n", DRPAI_DRIVER_VERSION DRPAI_DRV_DEBUG_MODE DRPAI_DRV_DEBUG_WAIT_MODE);
+    }
+    else
+    {
+        /* Do Nothing */
+    }
+
+    /* Get reserved register region from Device tree.*/
+    np = of_parse_phandle(pdev->dev.of_node, "sysctrl", 0);
+    if (!np) {
+        dev_err(&pdev->dev, "No %s specified\n", "sysctrl");
+        return -ENOMEM;
+    }
+
+    /* Convert register region to a struct resource */
+    ret = of_address_to_resource(np, 0, &reserved_res);
+    if (ret) {
+        dev_err(&pdev->dev, "No memory address assigned to the region\n");
+        return -ENOMEM;
+    }
+    sysctrl_region_base_addr = reserved_res.start;
+    dev_info(&pdev->dev, "sysctrl register region start 0x%016llX\n", sysctrl_region_base_addr);
+
+    /* Get reserved memory region from Device tree.*/
+    np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+    if (!np) {
+        dev_err(&pdev->dev, "No %s specified\n", "memory-region");
+        return -ENOMEM;
+    }
+
+    /* Convert memory region to a struct resource */
+    ret = of_address_to_resource(np, 0, &reserved_res);
+    if (ret) {
+        dev_err(&pdev->dev, "No memory address assigned to the region\n");
+        return -ENOMEM;
+    }
+    drpai_region_base_addr = reserved_res.start;
+    drpai_region_size = resource_size(&reserved_res);
+    dev_info(&pdev->dev, "DRP-AI memory region start 0x%016llX, size 0x%08llX\n", drpai_region_base_addr, drpai_region_size);
+
+    /* Get linux memory region from Device tree.*/
+    np = of_parse_phandle(pdev->dev.of_node, "linux-memory-region", 0);
+    if (!np) {
+        dev_err(&pdev->dev, "No %s specified\n", "linux-memory-region");
+        return -ENOMEM;
+    }
+
+    /* read linux start address and size */
+    ret = of_address_to_resource(np, 0, &reserved_res);
+    if (ret) {
+        dev_err(&pdev->dev, "No address assigned to the linux-memory-region\n");
+        return -ENOMEM;
+    }
+    drpai_linux_mem_start = reserved_res.start;
+    drpai_linux_mem_size = resource_size(&reserved_res);
+    dev_info(&pdev->dev, "linux-memory-region start 0x%016llX, size 0x%08llX\n", drpai_linux_mem_start, drpai_linux_mem_size);
+
+    /* Convert DRP base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    priv->drp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!priv->drp_base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    drp_base_addr[0] = priv->drp_base;
+    drp_size = resource_size(res);
+    dev_info(&pdev->dev, "DRP base address 0x%08llX, size 0x%08llX\n", res->start, drp_size);
+
+    /* Convert AI-MAC base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    priv->aimac_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!priv->aimac_base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    aimac_base_address[0] = priv->aimac_base;
+    aimac_size = resource_size(res);
+    dev_info(&pdev->dev, "AI-MAC base address 0x%08llX, size 0x%08llX\n", res->start, aimac_size);
+
+    /* Registering an interrupt handler */
+    irq = platform_get_irq(pdev, 1);
+    ret = devm_request_irq(&pdev->dev, irq, irq_drp_errint, 0, "drpa errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    irq = platform_get_irq(pdev, 2);
+    ret = devm_request_irq(&pdev->dev, irq, irq_mac_nmlint, 0, "drpa mac_nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    irq = platform_get_irq(pdev, 3);
+    ret = devm_request_irq(&pdev->dev, irq, irq_mac_errint, 0, "drpa mac_errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+
+    irq = platform_get_irq(pdev, 0);
+    ret = devm_request_irq(&pdev->dev, irq, irq_drp_nmlint, 0, "drpa nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    /* Get clock controller info */
+    priv->clk_int = devm_clk_get(&pdev->dev, "intclk");
+    if (IS_ERR(priv->clk_int)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_int);
+    }
+    
+    priv->clk_aclk_drp = devm_clk_get(&pdev->dev, "aclk_drp");
+    if (IS_ERR(priv->clk_aclk_drp)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_aclk_drp);
+    }
+    
+    priv->clk_mclk = devm_clk_get(&pdev->dev, "mclk");
+    if (IS_ERR(priv->clk_mclk)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_mclk);
+    }
+    
+    priv->clk_dclkin = devm_clk_get(&pdev->dev, "dclkin");
+    if (IS_ERR(priv->clk_dclkin)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_dclkin);
+    }
+    
+    priv->clk_aclk = devm_clk_get(&pdev->dev, "aclk");
+    if (IS_ERR(priv->clk_aclk)) {
+        dev_err(&pdev->dev, "missing controller clock");
+        return PTR_ERR(priv->clk_aclk);
+    }
+
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    /* Get reset controller info */
+    priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
+    if (IS_ERR(priv->rstc))
+    {
+        dev_err(&pdev->dev, "Failed to get DRP CPG reset controller\n");
+        return PTR_ERR(priv->rstc);
+    }
+    else
+    {
+        DRPAI_DEBUG_PRINT("Get DRP CPG reset controller\n");        
+    } 
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return 0;
+}
+
+static void drpai_unregist_driver(void)
+{
+    dev_t dev = MKDEV(drpai_major, MINOR_BASE);
+    int minor;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Delete "/sys/class/mydevice/mydevice*". */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        device_destroy(drpai_class, MKDEV(drpai_major, minor));
+    }
+
+    /* Destroy "/sys/class/mydevice/". */
+    class_destroy(drpai_class);
+
+    /* Delete cdev from kernel. */
+    cdev_del(&drpai_cdev);
+
+    /* Unregistration */
+    unregister_chrdev_region(dev, MINOR_NUM);
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static void drpai_unregist_device(void)
+{
+    DRPAI_DEBUG_PRINT("start.\n");
+    /* Do nothing */
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static int8_t drpai_reset_device(uint32_t ch)
+{
+    int8_t retval;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Reset DRP */
+    if(R_DRPAI_SUCCESS != R_DRPAI_DRP_Reset(drp_base_addr[0], aimac_base_address[0], ch, &priv->lock)) 
+    {
+        goto err_reset;
+    }
+
+    /* Reset AI-MAC */
+    if(R_DRPAI_SUCCESS != R_DRPAI_AIMAC_Reset(aimac_base_address[0], ch)) 
+    {
+        goto err_reset;
+    }
+
+    /* Reset CPG register */
+    if(R_DRPAI_SUCCESS != R_DRPAI_CPG_Reset(priv->rstc)) 
+    {
+        goto err_reset;
+    }
+
+    retval = R_DRPAI_SUCCESS;
+    goto end;
+err_reset:
+    retval = R_DRPAI_ERR_RESET;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return retval;
+}
+
+static void drpai_init_device(uint32_t ch)
+{
+    unsigned long flags;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->irq_flag = IRQ_CHECK_DISABLE;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    (void)R_DRPAI_DRP_Open(drp_base_addr[0], 0, &priv->lock);
+    (void)R_DRPAI_AIMAC_Open(aimac_base_address[0], 0);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static ssize_t drpai_write_dynamic(struct file *filp, uint8_t *pvirt)
+{
+    ssize_t result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(0 != (drpai_rw_status->drpai_data_dynamic.file_type & DRPAI_FILE_TYPE_DESC))
+    {
+        result = drpai_write_dynamic_desc(filp, pvirt);
+    }
+    else if (0 != (drpai_rw_status->drpai_data_dynamic.file_type & DRPAI_FILE_TYPE_PARAM))
+    {
+        result = drpai_write_dynamic_param(filp, pvirt);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static ssize_t drpai_write_dynamic_desc(struct file *filp, uint8_t *pvirt)
+{
+    ssize_t result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint32_t entry_num = drpai_rw_status->drpai_data_dynamic.size / DRP_DESC_ENTRY_SIZE; /* number of descriptor entry */
+    uint32_t entry_index;
+    uint8_t *entry;
+    uint8_t type;
+    uint8_t cf;
+    uint8_t mod;
+    uint8_t func;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* drp_desc.bin/aimac_desc.bin address rewriting. */
+    for(entry_index = 0; entry_index < entry_num; entry_index++)
+    {
+        entry = &pvirt[DRP_DESC_ENTRY_SIZE * entry_index];
+        type  = ((entry[DRP_DESC_TYPE_INDEX] >> DRP_DESC_TYPE_RSHIFT) & DRP_DESC_TYPE_MASK);
+        cf    = ((entry[DRP_DESC_CF_INDEX]   >> DRP_DESC_CF_RSHIFT)   & DRP_DESC_CF_MASK);
+        mod   = ((entry[DRP_DESC_MOD_INDEX]  >> DRP_DESC_MOD_RSHIFT)  & DRP_DESC_MOD_MASK);
+        func  = ((entry[DRP_DESC_FUNC_INDEX] >> DRP_DESC_FUNC_RSHIFT) & DRP_DESC_FUNC_MASK);
+
+        if(0 == type)
+        {
+            switch (cf)
+            {
+            /* DRP / DMA Transfer */
+            case DRP_DESC_CF_DRP_DMA:
+                if(0 == mod)
+                {
+                    if(0 == func)
+                    {
+                        DRPAI_DEBUG_PRINT("entry = %d: cf = %d, mod = %d, func = %d\n", entry_index, cf, mod, func);
+                        drpai_rewrite_address(&entry[DRP_DESC_ADDR_INDEX], drpai_rw_status->drpai_data_dynamic.start_address);
+                    }
+                }
+                break;
+
+            /* AIMAC / DMA Transfer */
+            case DRP_DESC_CF_AIMAC_DMA0:
+            case DRP_DESC_CF_AIMAC_DMA1:
+            case DRP_DESC_CF_AIMAC_DMA2:
+            case DRP_DESC_CF_AIMAC_DMA3:
+                if(0 == mod)
+                {
+                    if(0 == func)
+                    {
+                        DRPAI_DEBUG_PRINT("entry = %d: cf = %d, mod = %d, func = %d\n", entry_index, cf, mod, func);
+                        drpai_rewrite_address(&entry[DRP_DESC_ADDR_INDEX], drpai_rw_status->drpai_data_dynamic.start_address);
+                    }
+                }
+                break;
+
+            /* AIMAC / Parameter Transfer */
+            case DRP_DESC_CF_AIMAC_PARAM:
+                if(0 == mod)
+                {
+                    if(1 == func)
+                    {
+                        DRPAI_DEBUG_PRINT("entry = %d: cf = %d, mod = %d, func = %d\n", entry_index, cf, mod, func);
+                        drpai_rewrite_address(&entry[DRP_DESC_ADDR_INDEX], drpai_rw_status->drpai_data_dynamic.start_address);
+                    }
+                }
+                break;
+
+            /* CFG Load */
+            case DRP_DESC_CF_CFG_LOAD:
+                DRPAI_DEBUG_PRINT("entry = %d: cf = %d, mod = %d, func = %d\n", entry_index, cf, mod, func);
+                drpai_rewrite_address(&entry[DRP_DESC_ADDR_INDEX], drpai_rw_status->drpai_data_dynamic.start_address);
+                break;
+
+            default:
+                break;
+            }
+        }
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static ssize_t drpai_write_dynamic_param(struct file *filp, uint8_t *pvirt)
+{
+    ssize_t result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    char *ptr = drpai_rw_status->param_info;
+    char *prev_ptr;
+    char *buf = NULL;
+    uint32_t buf_len;
+    char *pbuf;
+    unsigned long offset_add = 0;
+    char *param_name;
+    int is_raddr;
+    int is_waddr;
+    char *paddr;
+    unsigned long param_offset;
+    struct param_info_list *list_top = NULL;
+    struct param_info_list *list_cur = NULL;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(NULL == ptr)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* drp_param_info.txt parsing */
+    while(('\0' != *ptr) && (ptr < drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size))
+    {
+        /* Save current pointer */
+        prev_ptr = ptr;
+
+        /* Get 1 line */
+        ptr = strchr(ptr, '\n');
+        if(NULL == ptr)
+        {
+            ptr = drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size;
+        }
+        else
+        {
+            ptr += 1;
+        }
+        if(ptr <= prev_ptr)
+        {
+            break;
+        }
+        buf_len = ptr - prev_ptr;
+
+        /* Copy only 1line to buffer */
+        buf = vmalloc(buf_len + 1);
+        if(NULL == buf)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        strncpy(buf, prev_ptr, buf_len);
+        buf[buf_len] = '\0';
+
+        /* Search and set offset_add */
+        pbuf = get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add, NULL);
+
+        /* Processing not "OFFSET_ADD" lines */
+        if(NULL == pbuf)
+        {
+            /* Register the offset values of the following parameters in the list */
+            /* - Name is "raddr" or "waddr"                                       */
+            /* - Name ends with "_ADDR"                                           */
+            pbuf = get_param_attr(buf, DRP_PARAM_ATTR_PARAM, NULL, &param_name);
+            if(NULL != pbuf)
+            {
+                is_raddr = strncmp(param_name, DRP_PARAM_NAME_RADDR, strlen(DRP_PARAM_NAME_RADDR));
+                is_waddr = strncmp(param_name, DRP_PARAM_NAME_WADDR, strlen(DRP_PARAM_NAME_WADDR));
+                paddr = strstr(param_name, DRP_PARAM_NAME_ADDR);
+                if(NULL != paddr)
+                {
+                    paddr += strlen(DRP_PARAM_NAME_ADDR);
+                }
+                if((0 == is_raddr) || (0 == is_waddr) || ((NULL != paddr) && ('\0' == *paddr)))
+                {
+                    pbuf = get_param_attr(pbuf, DRP_PARAM_ATTR_OFFSET, &param_offset, NULL);
+                    if(NULL != pbuf)
+                    {
+                        DRPAI_DEBUG_PRINT("offset_add = %d, param_name = %s, param_offset = %d\n", offset_add, param_name, param_offset);
+                        list_cur = param_info_list_push(&list_top, list_cur, offset_add + param_offset);
+                        if(NULL == list_cur)
+                        {
+                            result = -EFAULT;
+                            goto end;
+                        }
+                    }
+                }
+            }
+        }
+        vfree(buf);
+        buf = NULL;
+    }
+
+    /* drp_param.bin address rewriting. */
+    list_cur = list_top;
+    while (NULL != list_cur)
+    {
+        if((list_cur->offset + 4) <= drpai_rw_status->drpai_data_dynamic.size)
+        {
+            drpai_rewrite_address(&pvirt[list_cur->offset], drpai_rw_status->drpai_data_dynamic.start_address);
+        }
+
+        list_cur = list_cur->next;
+    }
+
+end:
+    if(NULL != buf)
+    {
+        vfree(buf);
+    }
+    param_info_list_clear(list_top);
+
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static void drpai_rewrite_address(uint8_t *pos, uint32_t addr)
+{
+    uint32_t original_addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    original_addr = (((uint32_t)pos[3] & 0xFF) << 24) |
+                    (((uint32_t)pos[2] & 0xFF) << 16) |
+                    (((uint32_t)pos[1] & 0xFF) <<  8) |
+                    (((uint32_t)pos[0] & 0xFF) <<  0);
+
+    original_addr += addr;
+
+    pos[0] = (uint8_t)((original_addr >>  0) & 0xFF);
+    pos[1] = (uint8_t)((original_addr >>  8) & 0xFF);
+    pos[2] = (uint8_t)((original_addr >> 16) & 0xFF);
+    pos[3] = (uint8_t)((original_addr >> 24) & 0xFF);
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static struct param_info_list* param_info_list_push(struct param_info_list **pptop, struct param_info_list* pcur, uint32_t offset)
+{
+    struct param_info_list *next = NULL;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(NULL == pptop)
+    {
+        goto end;
+    }
+
+    next = (struct param_info_list *)vmalloc(sizeof(struct param_info_list));
+    if(NULL != next)
+    {
+        next->offset = offset;
+        next->next = NULL;
+        if(NULL == *pptop)
+        {
+            *pptop = next;
+        }
+        else
+        {
+            if(NULL == pcur)
+            {
+                vfree(next);
+                next = NULL;
+                goto end;
+            }
+            pcur->next = next;
+        }
+    }
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return next;
+}
+
+static void param_info_list_clear(struct param_info_list* ptop)
+{
+    struct param_info_list* pos;
+    struct param_info_list* npos;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    pos = ptop;
+    while (pos != NULL)
+    {
+        npos = pos->next;
+        vfree(pos);
+        pos = npos;
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+static long drpai_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    volatile void *p_virt_address = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    struct drpai_rw_status *entry;
+    struct list_head *listitr;
+    drpai_data_t drpai_data_buf;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drpai_data_buf, (void __user *)arg, sizeof(drpai_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check Argument */
+    addr = priv->bank | (uint64_t)drpai_data_buf.address;
+    size = (uint64_t)drpai_data_buf.size;
+    if (0 != (addr & DRPAI_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if ((drpai_region_base_addr > addr) || 
+       ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (0 == size)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check the assigned address */
+    DRPAI_DEBUG_PRINT("list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    if(!list_empty(&drpai_rw_sentinel->list))
+    {   
+        DRPAI_DEBUG_PRINT("List is not empty\n");
+        list_for_each(listitr, &drpai_rw_sentinel->list)
+        {
+            entry = list_entry(listitr, struct drpai_rw_status, list);
+            DRPAI_DEBUG_PRINT("rw_status %d list %px prev %px next %px\n", entry->rw_status, &entry->list, entry->list.prev, entry->list.next);
+            if( (DRPAI_STATUS_ASSIGN   == entry->rw_status) ||
+                (DRPAI_STATUS_WRITE    == entry->rw_status) ||
+                (DRPAI_STATUS_READ_MEM == entry->rw_status)    )
+            {
+                if(!(  (entry->drpai_data.address > (drpai_data_buf.address + drpai_data_buf.size - 1)) ||
+                      ((entry->drpai_data.address + entry->drpai_data.size - 1) < drpai_data_buf.address)  ))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+            }
+            else if(    (DRPAI_STATUS_ASSIGN_DYNAMIC == entry->rw_status)||
+                        (DRPAI_STATUS_WRITE_DYNAMIC  == entry->rw_status)   )
+            {
+                if(!( ((entry->drpai_data_dynamic.start_address + entry->drpai_data_dynamic.offset) > (drpai_data_buf.address + drpai_data_buf.size - 1)) ||
+                      ((entry->drpai_data_dynamic.start_address + entry->drpai_data_dynamic.offset + entry->drpai_data.size - 1) < drpai_data_buf.address)   ))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+            }
+        }
+    }
+
+    /* Data cache invalidate. DRP-AI W -> CPU R */
+    addr = priv->bank | (uint64_t)drpai_data_buf.address;
+    p_virt_address = phys_to_virt(addr);
+    if (p_virt_address == 0)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    __inval_dcache_area((void *)p_virt_address, drpai_data_buf.size);
+
+    /* Initialization of read / write processing variables */
+    drpai_rw_status->drpai_data  = drpai_data_buf;
+    drpai_rw_status->rw_status   = DRPAI_STATUS_ASSIGN;
+    drpai_rw_status->write_count = 0;
+    drpai_rw_status->read_count  = 0;
+    /* Register assigned status */
+    list_add(&drpai_rw_status->list, &drpai_rw_sentinel->list);
+    DRPAI_DEBUG_PRINT("Registered list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_assign_dynamic(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    struct drpai_rw_status *entry;
+    struct list_head *listitr;
+    drpai_data_dynamic_t drpai_data_dynamic_buf;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drpai_data_dynamic_buf, (void __user *)arg, sizeof(drpai_data_dynamic_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check Argument */
+    if (0 != (drpai_data_dynamic_buf.start_address & DRPAI_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    addr = priv->bank | ((uint64_t)drpai_data_dynamic_buf.start_address + (uint64_t)drpai_data_dynamic_buf.offset);
+    size = (uint64_t)drpai_data_dynamic_buf.size;
+    if (0 != (addr & DRPAI_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if ((drpai_region_base_addr > addr) || 
+       ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (0 == size)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check the assigned address */
+    DRPAI_DEBUG_PRINT("list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+    if(!list_empty(&drpai_rw_sentinel->list))
+    {   
+        DRPAI_DEBUG_PRINT("List is not empty\n");
+        list_for_each(listitr, &drpai_rw_sentinel->list)
+        {
+            entry = list_entry(listitr, struct drpai_rw_status, list);
+            DRPAI_DEBUG_PRINT("rw_status %d list %px prev %px next %px\n", entry->rw_status, &entry->list, entry->list.prev, entry->list.next);
+            if( (DRPAI_STATUS_ASSIGN   == entry->rw_status) ||
+                (DRPAI_STATUS_WRITE    == entry->rw_status) ||
+                (DRPAI_STATUS_READ_MEM == entry->rw_status)    )
+            {
+                if(!(  (entry->drpai_data.address > (drpai_data_dynamic_buf.start_address + drpai_data_dynamic_buf.offset + drpai_data_dynamic_buf.size - 1)) ||
+                      ((entry->drpai_data.address + entry->drpai_data.size - 1) < (drpai_data_dynamic_buf.start_address + drpai_data_dynamic_buf.offset))        ))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+            }
+            else if(    (DRPAI_STATUS_ASSIGN_DYNAMIC == entry->rw_status)||
+                        (DRPAI_STATUS_WRITE_DYNAMIC  == entry->rw_status)   )
+            {
+                if(!( ((entry->drpai_data_dynamic.start_address + entry->drpai_data_dynamic.offset) >
+                           (drpai_data_dynamic_buf.start_address + drpai_data_dynamic_buf.offset + drpai_data_dynamic_buf.size - 1)) ||
+                      ((entry->drpai_data_dynamic.start_address + entry->drpai_data_dynamic.offset + entry->drpai_data_dynamic.size - 1) <
+                           (drpai_data_dynamic_buf.start_address + drpai_data_dynamic_buf.offset))                                          ))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+            }
+        }
+    }
+
+    /* Initialization of read / write processing variables */
+    drpai_rw_status->drpai_data_dynamic = drpai_data_dynamic_buf;
+    drpai_rw_status->rw_status          = DRPAI_STATUS_ASSIGN_DYNAMIC;
+    drpai_rw_status->write_count        = 0;
+    drpai_rw_status->read_count         = 0;
+    /* Register assigned status */
+    list_add(&drpai_rw_status->list, &drpai_rw_sentinel->list);
+    DRPAI_DEBUG_PRINT("Registered list %px prev %px next %px\n", &drpai_rw_status->list, drpai_rw_status->list.prev, drpai_rw_status->list.next);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int result = 0;
+    drpai_data_t proc[DRPAI_INDEX_NUM];
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* DRP single operation */
+    drpai_data_t proc_drp[DRPAI_SEQ_NUM * 2];
+/* DRP single operation */
+#endif /* CONFIG_ARCH_R9A07G054 */
+    volatile void *p_drp_desc = 0;
+    volatile void *p_aimac_desc = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    int i;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* DRP single operation */
+    if(DRPAI_EXE_AI == exe_mode)
+    {
+#endif
+        /* Copy arguments from user space to kernel space */
+        if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Check Argument */
+        for (i = DRPAI_INDEX_DRP_DESC; i < DRPAI_INDEX_NUM; i++)
+        {
+            addr = priv->bank | (uint64_t)proc[i].address;
+            size = (uint64_t)proc[i].size;
+            if (0 != (addr & DRPAI_64BYTE_ALIGN))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+            if ((drpai_region_base_addr > addr) || 
+            ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
+                {
+                    result = -EINVAL;
+                    goto end;
+                }
+        }
+
+        /* Check if input is in linux memory region */
+        if(0 == atomic_read(&drpai_rw_status->inout_flag))
+        {
+            DRPAI_DEBUG_PRINT("Use arg variable\n");
+            addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_INPUT].address;
+            size = (uint64_t)proc[DRPAI_INDEX_INPUT].size;
+            if(0 != drpai_flush_dcache_input_area(addr, size))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+            /* Change input address to value specified by user app. */
+            addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_DRP_PARAM].address;
+            if(0 != drp_param_change32(addr, 0, proc[DRPAI_INDEX_INPUT].address))
+            {
+                result = -EFAULT;
+                goto end;
+            }
+        }
+        
+        /* drp_desc.bin */
+        addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_DRP_DESC].address;
+        p_drp_desc = phys_to_virt(addr);
+        if (p_drp_desc == 0)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Changed link descriptor of drp_desc.bin */
+        if (0 != (proc[DRPAI_INDEX_DRP_DESC].size & 0x0F))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+        iowrite8(0x08, p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13);
+        __flush_dcache_area((void *)(p_drp_desc + proc[DRPAI_INDEX_DRP_DESC].size - 13), 1);
+
+        /* aimac_desc.bin */
+        addr = priv->bank | (uint64_t)proc[DRPAI_INDEX_AIMAC_DESC].address;
+        p_aimac_desc = phys_to_virt(addr);
+        if (p_aimac_desc == 0)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Changed link descriptor of drp_desc.bin */
+        if (0 != (proc[DRPAI_INDEX_AIMAC_DESC].size & 0x0F))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+        iowrite8(0x08, p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13);
+        __flush_dcache_area((void *)(p_aimac_desc + proc[DRPAI_INDEX_AIMAC_DESC].size - 13), 1);
+
+        spin_lock_irqsave(&priv->lock, flags);
+        /* Init drpai_status.err */
+        priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+        /* IDLE -> RUN */
+        priv->drpai_status.status = DRPAI_STATUS_RUN;
+        priv->irq_flag = IRQ_CHECK_ENABLE;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+        /* Kick */
+        (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, proc[DRPAI_INDEX_DRP_DESC].address);
+        (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, proc[DRPAI_INDEX_AIMAC_DESC].address, &priv->lock);
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    }
+    else if (DRPAI_EXE_DRP == exe_mode)
+    {
+        odif_intcnto.ch0 = 0;
+        odif_intcnto.ch1 = 0;
+        odif_intcnto.ch2 = 0;
+        odif_intcnto.ch3 = 0;
+
+        DRPAI_DEBUG_PRINT("DRP exe mode:%d\n", exe_mode);
+        if (copy_from_user(&proc_drp[0], (void __user *)arg, sizeof(proc_drp)))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        /* Check Argument */
+        for (i = 0; i < (seq.num * 2); i++)
+        {
+            if (0 != (proc_drp[i].address & DRPAI_64BYTE_ALIGN))
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+        for (i = 0; i < seq.num; i++)
+        {
+            /* DRPcfg address and size settings */
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_drp[i * 2].address;
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_drp[i * 2].size;
+
+            /* DRP param address and size settings */
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_drp[i * 2 + 1].address;
+            *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_drp[i * 2 + 1].size;
+
+            /* Link descriptor settings */
+            if (i < (seq.num - 1))
+            {
+                /* LV enable */
+                *(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 67) = 0x09;
+
+                /* Link pointer settings */
+                if (DRPAI_DRP_NOLOAD == proc_drp[(i + 1) * 2].address)
+                {
+                    *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 68)
+                    = p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * (i + 1)) + DRPAI_DESC_CMD_SIZE;
+                }
+                else
+                {
+                    *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 68)
+                    = p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * (i + 1));
+                }
+            }
+            else
+            {
+                /* LV disable */
+                *(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 67) = 0x08;
+            }
+        }
+        __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+        /* DRPcfg load skip */
+        if (DRPAI_DRP_NOLOAD == proc_drp[0].address)
+        {
+            p_dmabuf_phyaddr = p_dmabuf_phyaddr + DRPAI_DESC_CMD_SIZE;
+        }
+
+        spin_lock_irqsave(&priv->lock, flags);
+        /* Init drpai_status.err */
+        priv->drpai_status.err = DRPAI_ERRINFO_SUCCESS;
+        /* IDLE -> RUN */
+        priv->drpai_status.status = DRPAI_STATUS_RUN;
+        priv->irq_flag = IRQ_CHECK_ENABLE;
+        spin_unlock_irqrestore(&priv->lock, flags);
+        DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+        /* Kick */
+        (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, p_dmabuf_phyaddr);
+        (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM), &priv->lock);
+    }
+    else
+    {
+        // do nothing
+    }
+/* DRP single operation */
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+#ifdef DRPAI_DRV_DEBUG
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+#endif
+    unsigned long flags;
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    void (*finish_callback)(int);
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    /* ISP */
+    spin_lock_irqsave(&priv->lock, flags);
+    finish_callback = drpai_priv->isp_finish_loc;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    /* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        result = -EIO;
+        goto end;
+    }
+    drpai_init_device(0);
+
+    /* Update internal state */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.err    = DRPAI_ERRINFO_RESET;
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->irq_flag            = IRQ_CHECK_DISABLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &drpai_waitq );
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    /* ISP */
+    /* For reset ISP call back*/    
+    if(NULL != finish_callback)
+    {
+        /* ERROR No.: ERESTART*/
+        (*finish_callback)(-ERESTART);
+    }
+    spin_lock_irqsave(&priv->lock, flags);    
+    drpai_priv->isp_finish_loc = NULL;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    /* For reset ISP call back*/
+    /* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+
+    result = 0;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_status_t local_drpai_status;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT(" \n");
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Get the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    (void)R_DRPAI_Status(drp_base_addr[0], aimac_base_address[0], 0, &priv->drpai_status);
+
+    /* Copy arguments from kernel space to user space */
+    local_drpai_status = priv->drpai_status;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    if (copy_to_user((void __user *)arg, &local_drpai_status, sizeof(drpai_status_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRPAI_STATUS_RUN == local_drpai_status.status)
+    {
+        result = -EBUSY;
+        goto end;
+    }
+
+    /* Check DRP-AI H/W error */
+    if ((DRPAI_ERRINFO_DRP_ERR == local_drpai_status.err) || (DRPAI_ERRINFO_AIMAC_ERR == local_drpai_status.err))
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_reg_dump(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&rw_sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT(" \n");
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check of writing and reading completion of DRP-AI obj file */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Initialization of register dump processing variables */
+    drpai_rw_status->rw_status              = DRPAI_STATUS_DUMP_REG;
+    drpai_rw_status->read_count             = 0;
+    drpai_rw_status->drp_reg_offset_count   = 0;
+    drpai_rw_status->aimac_reg_offset_count = 0;
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_assign_param(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_assign_param_t drpai_assign_param_buf;
+    struct drpai_priv *priv = drpai_priv;
+    char *vbuf;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+	/* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+    /* Check status */
+    if (DRPAI_STATUS_IDLE_RW != drpai_rw_status->rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+    if(drpai_rw_status->param_info)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drpai_assign_param_buf, (void __user *)arg, sizeof(drpai_assign_param_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if((0 == drpai_assign_param_buf.info_size) || (0 == drpai_assign_param_buf.obj.size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    addr = priv->bank | (uint64_t)drpai_assign_param_buf.obj.address;
+    size = (uint64_t)drpai_assign_param_buf.obj.size;
+    if ((drpai_region_base_addr > addr) || 
+        ((drpai_region_base_addr + drpai_region_size) <= (addr + size)))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    
+    /* Allocate memory for *_param_info.txt */
+    vbuf = vmalloc(drpai_assign_param_buf.info_size + 1);
+    if(!vbuf){
+        result = -EFAULT;
+        goto end;
+    }
+    vbuf[drpai_assign_param_buf.info_size] = '\0';
+
+    /* Initialization of read / write processing variables */
+    drpai_rw_status->rw_status    = DRPAI_STATUS_ASSIGN_PARAM;
+    drpai_rw_status->write_count  = 0;
+    drpai_rw_status->assign_param = drpai_assign_param_buf;
+    drpai_rw_status->param_info   = vbuf;
+
+    DRPAI_DEBUG_WAIT();
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+/* Note: This function change line variable. so if you use, check your variables address */
+static char* get_param_attr(char *line, char *attr, unsigned long *rvalue, char **str)
+{
+    char *result;
+    char *ptr_stmp, *ptr_etmp;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if((NULL == line) || (NULL == attr))
+    {
+        result = NULL;
+        goto end;
+    }
+
+    ptr_stmp = strstr(line, attr);
+    if(NULL == ptr_stmp)
+    {
+        result = NULL;
+        goto end;
+    }
+    ptr_stmp += strlen(attr);
+    ptr_etmp = strstr(ptr_stmp, ",");
+    if(NULL == ptr_etmp)
+    {
+        result = NULL;
+        goto end;
+    }
+    *ptr_etmp = '\0';
+    if(NULL != rvalue)
+    {
+        if(0 != kstrtoul(ptr_stmp, 10, rvalue))
+        {
+            result = NULL;
+            goto end;
+        }
+    }
+    if(NULL != str)
+    {
+        *str = ptr_stmp;
+    }
+    result = ptr_etmp + 1;
+
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int8_t drpai_get_sys_bank(uint64_t *bank)
+{
+    int8_t result = 0;
+    void __iomem *base = NULL;
+    uint32_t reg_val;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    base = ioremap(sysctrl_region_base_addr, SYS_SIZE);
+    if (!base) {
+        result = -1;
+        goto end;
+    }
+    reg_val = ioread32(base + SYS_DRP_BANK);
+    *bank = ((uint64_t)reg_val & SYS_MASK_DRP) << SYS_SHIFT;
+    DRPAI_DEBUG_PRINT("SYS_DRP_BANK = 0x%08X\n", reg_val);
+    DRPAI_DEBUG_PRINT("bank = 0x%016llX\n", *bank);
+    goto end;
+end:
+    if(base)
+    {
+        iounmap(base);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int8_t drp_param_change16(uint64_t base, uint64_t offset, uint16_t value)
+{
+    int8_t result = 0;
+    volatile void *virt_addr = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    virt_addr = phys_to_virt(base + offset);
+    if (0 == virt_addr)
+    {
+        result = -1;
+        goto end;
+    }
+    iowrite16(value, (void *)virt_addr);
+    __flush_dcache_area((void *)virt_addr, sizeof(value));
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+static int8_t drp_param_change32(uint64_t base, uint64_t offset, uint32_t value)
+{
+    int8_t result = 0;
+    volatile void *virt_addr = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    virt_addr = phys_to_virt(base + offset);
+    if (0 == virt_addr)
+    {
+        result = -1;
+        goto end;
+    }
+    iowrite32(value, (void *)virt_addr);
+    __flush_dcache_area((void *)virt_addr, sizeof(value));
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+static int8_t drpai_flush_dcache_input_area(uint64_t addr, uint64_t size)
+{
+    int8_t result = 0;
+    uint64_t flush_addr, flush_size;
+    uint64_t input_saddr, input_eaddr, linux_mem_saddr, linux_mem_eaddr;
+    volatile void *p_input = 0;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    input_saddr      = addr;
+    input_eaddr      = addr + size - 1;
+    linux_mem_saddr  = drpai_linux_mem_start;
+    linux_mem_eaddr  = drpai_linux_mem_start + drpai_linux_mem_size - 1;
+    if ((input_saddr >= linux_mem_saddr) && 
+        (input_eaddr <= linux_mem_eaddr))
+    {
+        flush_addr = addr;
+        flush_size = size;
+    }
+    else if ((input_saddr >= linux_mem_saddr) &&
+             (input_saddr <= linux_mem_eaddr) &&
+             (input_eaddr >  linux_mem_eaddr))
+    {
+        flush_addr = addr;
+        flush_size = (drpai_linux_mem_start + drpai_linux_mem_size) - addr;
+    }
+    else if((input_eaddr >= linux_mem_saddr) &&
+            (input_eaddr <= linux_mem_eaddr) &&
+            (input_saddr <  linux_mem_saddr))
+    {
+        flush_addr = drpai_linux_mem_start;
+        flush_size = (addr + size) - drpai_linux_mem_start;
+    }
+    else
+    {
+        flush_addr = 0;
+        flush_size = 0;
+    }
+    DRPAI_DEBUG_PRINT("flush_addr = 0x%016llX, flush_size = 0x%08X\n", flush_addr, flush_size);
+    if (0 != flush_size)
+    {
+        /* Input data area cache flush */
+        p_input = phys_to_virt(flush_addr);
+        if (0 == p_input)
+        {
+            result = -1;
+            goto end;
+        }
+        __flush_dcache_area((void *)p_input, flush_size);
+    }
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static long drpai_ioctl_prepost_crop(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_crop_t crop_param_buf;
+    char *buf = NULL;
+    uint32_t buf_len;
+    char *ptr;
+    char *prev_ptr;
+    unsigned long offset_add0;
+    unsigned long offset_add1;
+    int mode = 0;
+    uint64_t addr;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if((NULL == drpai_rw_status->param_info) ||
+       (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
+       (DRPAI_STATUS_WRITE_PARAM  == drpai_rw_status->rw_status))
+    {
+        result = -EACCES;
+        goto end;
+    }
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&crop_param_buf, (void __user *)arg, sizeof(drpai_crop_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check if there is in drpai dedicated area */
+    if((drpai_rw_status->assign_param.obj.address != crop_param_buf.obj.address) ||
+       (drpai_rw_status->assign_param.obj.size != crop_param_buf.obj.size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Search argument */
+    ptr = drpai_rw_status->param_info;
+    while(1)
+    {
+        /* End of info_buf */
+        if(('\0' == *ptr) || (ptr >= drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+
+        /* Save current pointer */
+        prev_ptr = ptr;
+
+        /* Get 1 line */
+        ptr = strchr(ptr, '\n');
+        if(NULL == ptr)
+        {
+            ptr = drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size;
+        }
+        else
+        {
+            ptr += 1;
+        }
+        if(ptr <= prev_ptr)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        buf_len = ptr - prev_ptr;
+
+        /* Copy only 1line to buffer */
+        buf = vmalloc(buf_len + 1);
+        if(NULL == buf)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        strncpy(buf, prev_ptr, buf_len);
+        buf[buf_len] = '\0';
+
+        if(0 == mode)
+        {
+            /* Check if there is DRP_LIB_NAME_CROP in this line */
+            if(NULL != strstr(buf, DRP_LIB_NAME_CROP))
+            {
+                mode += 1;
+                if(NULL == get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add0, NULL))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+            }
+        }
+        else if(1 == mode)
+        {
+            if(NULL != strstr(buf, DRP_PARAM_ATTR_OFFSET_ADD))
+            {
+                mode += 1;
+                if(NULL == get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add1, NULL))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+                break;
+            }
+        }
+        vfree(buf);
+        buf = NULL;
+    }
+
+    DRPAI_DEBUG_PRINT("offset_add0=%d, offset_add1=%d\n", offset_add0, offset_add1);
+
+    /* Change parameters of drp_param.bin to value specified by user app. */
+    addr = priv->bank | (uint64_t)crop_param_buf.obj.address;
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_IMG_OWIDTH, crop_param_buf.img_owidth))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_IMG_OHEIGHT, crop_param_buf.img_oheight))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_CROP_POS_X, crop_param_buf.pos_x))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add0 + DRP_PARAM_CROP_POS_Y, crop_param_buf.pos_y))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add1 + DRP_PARAM_IMG_IWIDTH, crop_param_buf.img_owidth))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if(0 != drp_param_change16(addr, (uint64_t)offset_add1 + DRP_PARAM_IMG_IHEIGHT, crop_param_buf.img_oheight))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+end:
+    DRPAI_DEBUG_WAIT();
+
+    if(NULL != buf)
+    {
+        vfree(buf);
+    }
+    if((-EBUSY != result) || (-ERESTART != result))
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+static long drpai_ioctl_prepost_inaddr(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    struct drpai_rw_status *drpai_rw_status = filp->private_data;
+    drpai_inout_t inout_param_buf;
+    char *buf = NULL;
+    uint32_t buf_len;
+    char *ptr;
+    char *prev_ptr;
+    unsigned long flags;
+    unsigned long offset_add;
+    uint64_t addr, size;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if(DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("status_rw1:%d\n", drpai_rw_status->rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if((NULL == drpai_rw_status->param_info) ||
+       (DRPAI_STATUS_ASSIGN_PARAM == drpai_rw_status->rw_status) ||
+       (DRPAI_STATUS_WRITE_PARAM  == drpai_rw_status->rw_status))
+    {
+        result = -EACCES;
+        goto end;
+    }
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&inout_param_buf, (void __user *)arg, sizeof(drpai_inout_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check if there is in drpai dedicated area */
+    if((drpai_rw_status->assign_param.obj.address != inout_param_buf.obj.address) ||
+       (drpai_rw_status->assign_param.obj.size != inout_param_buf.obj.size))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Search argument */
+    ptr = drpai_rw_status->param_info;
+    while(1)
+    {
+        /* End of info_buf */
+        if(('\0' == *ptr) || (ptr >= drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+
+        /* Save current pointer */
+        prev_ptr = ptr;
+
+        /* Get 1 line */
+        ptr = strchr(ptr, '\n');
+        if(NULL == ptr)
+        {
+            ptr = drpai_rw_status->param_info + drpai_rw_status->assign_param.info_size;
+        }
+        else
+        {
+            ptr += 1;
+        }
+        if(ptr <= prev_ptr)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        buf_len = ptr - prev_ptr;
+
+        /* Copy only 1line to buffer */
+        buf = vmalloc(buf_len + 1);
+        if(NULL == buf)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        strncpy(buf, prev_ptr, buf_len);
+        buf[buf_len] = '\0';
+
+        /* Check if there is DRP_PARAM_ATTR_PROP_INPUT in this line */
+        if(NULL != strstr(buf, DRP_PARAM_ATTR_PROP_INPUT))
+        {
+            if(NULL != strstr(buf, inout_param_buf.name))
+            {
+                if(NULL == get_param_attr(buf, DRP_PARAM_ATTR_OFFSET_ADD, &offset_add, NULL))
+                {
+                    result = -EFAULT;
+                    goto end;
+                }
+                break;
+            }
+        }
+        vfree(buf);
+        buf = NULL;
+    }
+
+    DRPAI_DEBUG_PRINT("offset_add=%d\n", offset_add);
+
+    /* Check if input is in linux memory region */
+    addr = priv->bank | (uint64_t)inout_param_buf.data.address;
+    size = (uint64_t)inout_param_buf.data.size;
+    if(0 != drpai_flush_dcache_input_area(addr, size))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Change parameters of drp_param.bin to value specified by user app. */
+    addr = priv->bank | (uint64_t)inout_param_buf.obj.address;
+    if(0 != drp_param_change32(addr, (uint64_t)offset_add + DRP_PARAM_raddr, inout_param_buf.data.address))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    atomic_set(&drpai_rw_status->inout_flag, 1);
+
+    goto end;
+end:
+    DRPAI_DEBUG_WAIT();
+
+    if(NULL != buf)
+    {
+        vfree(buf);
+    }
+    if((-EBUSY != result) || (-ERESTART != result))
+    {
+        up(&rw_sem);
+    }
+    DRPAI_DEBUG_PRINT("status_rw2:%d\n", drpai_rw_status->rw_status);
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+static long drpai_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT(" start.\n");
+    DRPAI_DEBUG_PRINT(" status1:%d\n", priv->drpai_status.status);
+
+    /* Check the internal state of DRP-AI */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&seq, (void __user *)arg, sizeof(drpai_seq_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check Argument DRP Simgle */
+    if (DRPAI_SEQ_NUM < seq.num)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (DRPAI_EXE_DRP == seq.order[0])
+    {
+        exe_mode = DRPAI_EXE_DRP;
+    }
+    else if (DRPAI_EXE_AI == seq.order[0])
+    {
+        exe_mode = DRPAI_EXE_AI;
+    }
+    else
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT(" DRP exe mode:%d\n", exe_mode);
+
+    DRPAI_DEBUG_PRINT(" status2:%d\n", priv->drpai_status.status);
+end:
+    DRPAI_DEBUG_PRINT(" end.\n");
+
+    return result;
+}
+/* DRP single operation */
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+static long drpai_ioctl_get_drpai_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drpai_data_t local_drpai_data;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    local_drpai_data.address = drpai_region_base_addr;
+    local_drpai_data.size    = drpai_region_size;
+
+    if (copy_to_user((void __user *)arg, &local_drpai_data, sizeof(drpai_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drpai_drp_cpg_init(void)
+{
+    int result;
+    struct drpai_priv *priv = drpai_priv;
+    int r_data;
+    int32_t i = 0;
+    bool is_stop = false;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    /* Access clock interface */
+    clk_prepare_enable(priv->clk_int);
+    clk_prepare_enable(priv->clk_aclk_drp);
+    clk_prepare_enable(priv->clk_mclk);
+    clk_prepare_enable(priv->clk_dclkin);
+    clk_prepare_enable(priv->clk_aclk);
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    r_data = reset_control_status(priv->rstc);
+    DRPAI_DEBUG_PRINT("CPG reset_control_status before %d \n", r_data);
+    
+    /* Access reset controller interface */
+    reset_control_reset(priv->rstc);
+
+    /* Check reset status */
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRPAI_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRPAI_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(true == is_stop)
+    {
+        result =  R_DRPAI_SUCCESS;
+    }
+    else
+    {
+        result = R_DRPAI_ERR_RESET;
+        DRPAI_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
+    }
+
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static int drpai_open_process(void)
+{
+    int ret;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+    uint64_t bank;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Initialize CPG */
+    if(R_DRPAI_SUCCESS != drpai_drp_cpg_init())
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP-AI */
+    drpai_init_device(0);
+
+    /* Reset DRP-AI */
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP-AI */
+    drpai_init_device(0);
+
+    /* Get sys register value */
+    if(0 != drpai_get_sys_bank(&bank))
+    {
+        ret = -EFAULT;
+        goto end;
+    }
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    if(R_DRPAI_SUCCESS != drpai_drp_config_init())
+    {
+        ret = -ENOMEM;
+        goto end;
+    }
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    /* INIT -> IDLE */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.status = DRPAI_STATUS_IDLE;
+    priv->bank = bank;
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    exe_mode = DRPAI_EXE_AI;
+#endif /* CONFIG_ARCH_R9A07G054 */
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int drpai_close_process(void)
+{
+    int ret;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(R_DRPAI_SUCCESS != drpai_reset_device(0))
+    {
+        ret = -EIO;
+        goto end;
+    }
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+    //CPG clock disable
+    DRPAI_DEBUG_PRINT("CPG clock disable\n");
+    clk_disable_unprepare(priv->clk_int);
+    clk_disable_unprepare(priv->clk_aclk_drp);
+    clk_disable_unprepare(priv->clk_mclk);
+    clk_disable_unprepare(priv->clk_dclkin);
+    clk_disable_unprepare(priv->clk_aclk);  
+
+    drpai_drp_config_uninit();
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+    /* IDLE -> INIT */
+    /* RUN  -> INIT */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drpai_status.status = DRPAI_STATUS_INIT;
+    priv->drpai_status.err    = DRPAI_ERRINFO_SUCCESS;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    ret = R_DRPAI_SUCCESS;
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+/* V2L conditional compilation */
+#ifdef CONFIG_ARCH_R9A07G054
+/* ISP */
+static int drpai_drp_config_init(void)
+{
+    int result;
+    struct drpai_priv *priv = drpai_priv;
+    struct device *dev = &priv->pdev->dev;
+    int i;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    /* Get driver workspace from Linux CMA */
+    p_dmabuf_vaddr = dma_alloc_coherent(dev, DRPAI_CMA_SIZE, &p_dmabuf_phyaddr, GFP_DMA);
+    if (NULL == p_dmabuf_vaddr)
+    {
+        /* Error -ENOMEM */
+        result = -1;
+        goto end;
+    }
+    DRPAI_DEBUG_PRINT("dmabuf:0x%08X, dmaphys:0x%08X\n", p_dmabuf_vaddr, p_dmabuf_phyaddr);
+
+    /* 64bytes alignment adjustment */
+    if (0 != (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN))
+    {
+        p_dmabuf_vaddr = p_dmabuf_vaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
+        p_dmabuf_phyaddr = p_dmabuf_phyaddr + (0x40 - (p_dmabuf_phyaddr & DRPAI_64BYTE_ALIGN));
+    }
+
+/* DRP single operation */
+    /* Deploy drp_single_desc */
+    for (i = 0; i < DRPAI_SEQ_NUM; i++)
+    {
+        memcpy(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i), &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
+    }
+/* DRP single operation */
+
+    __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+    result = R_DRPAI_SUCCESS;
+
+    goto end;
+end:
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+static void drpai_drp_config_uninit(void)
+{
+    struct drpai_priv *priv = drpai_priv;
+    struct device *dev = &priv->pdev->dev;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    dma_free_coherent(dev, DRPAI_CMA_SIZE, p_dmabuf_vaddr, p_dmabuf_phyaddr);
+    DRPAI_DEBUG_PRINT("end.\n");
+}
+
+int drpai_open_k(void)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEDOUT.\n");
+        goto end;
+    }  
+
+    if(likely(1 == refcount_read(&priv->count)))
+    {
+        result = drpai_open_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            goto end;
+        }
+    }
+
+    /* Increment reference count */
+    refcount_inc(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:%d\n", priv->drpai_status.status);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+int drpai_close_k(void)
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    unsigned long flags;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
+        goto end;
+    } 
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_INIT == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EACCES;        
+        DRPAI_DEBUG_PRINT("EACCES.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    if(2 == refcount_read(&priv->count))
+    {
+        result = drpai_close_process();
+        if(R_DRPAI_SUCCESS != result)
+        {
+            goto end;
+        }
+    }
+
+    /* Decrement referenece count*/
+    refcount_dec(&priv->count);
+
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+
+int drpai_start_k(drpai_data_t *arg, void (*isp_finish)(int result))
+{
+    int result = 0;
+    struct drpai_priv *priv = drpai_priv;
+    drpai_data_t *proc_k;
+    unsigned long flags;
+    int i;
+
+    DRPAI_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        DRPAI_DEBUG_PRINT("ETIMEOUT.\n");
+        goto end;
+    }
+
+    DRPAI_DEBUG_PRINT("status1:   %d\n", priv->drpai_status.status);
+
+    /* Check H/W Error */
+    spin_lock_irqsave(&priv->lock, flags);
+    if ((DRPAI_ERRINFO_DRP_ERR == priv->drpai_status.err) || (DRPAI_ERRINFO_AIMAC_ERR == priv->drpai_status.err))
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EIO;   
+        DRPAI_DEBUG_PRINT("EIO.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_RUN == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;   
+        DRPAI_DEBUG_PRINT("EBUSY.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRPAI_STATUS_INIT == priv->drpai_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EACCES;   
+        DRPAI_DEBUG_PRINT("EACCES.\n");
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check NULL */
+    if (NULL == isp_finish)
+    {
+        result = -EINVAL; 
+        DRPAI_DEBUG_PRINT("EINVAL NULL function pointer.\n");
+        goto end;
+    }
+    /* Referring the call back function info from ISP Lib */
+    priv->isp_finish_loc = isp_finish;  
+
+    /* Check NULL */
+    if (NULL == arg)
+    {
+        result = -EINVAL; 
+        DRPAI_DEBUG_PRINT("EINVAL NULL argument pointer.\n");
+        goto end;
+    }
+    /* Referring the obj file info from ISP Lib */
+    proc_k = arg;
+
+    spin_lock_irqsave(&priv->lock, flags);
+    odif_intcnto.ch0 = 0;
+    odif_intcnto.ch1 = 0;
+    odif_intcnto.ch2 = 0;
+    odif_intcnto.ch3 = 0;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO1 : 0x%08X\n", odif_intcnto.ch1);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO2 : 0x%08X\n", odif_intcnto.ch2);
+    DRPAI_DEBUG_PRINT("ODIF_INTCNTO3 : 0x%08X\n", odif_intcnto.ch3);
+
+    /* Check Argument 64-byte*/
+    for (i = 0; i < 2; i++)
+    {
+        if (0 != (proc_k[i].address & DRPAI_64BYTE_ALIGN))
+        {
+            result = -EINVAL; 
+            DRPAI_DEBUG_PRINT("EINVAL argument. Not 64-byte aligned.\n");
+            goto end;
+        }
+    }
+
+    for (i = 0; i < 1; i++)
+    {
+        /* DRPcfg address and size settings */
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 4) = proc_k[i * 2].address;
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 8) = proc_k[i * 2].size;
+
+        DRPAI_DEBUG_PRINT("cfg_address:0x%08X, cfg_size:0x%08X\n", proc_k[i * 2].address, proc_k[i * 2].size);
+
+        /* DRP param address and size settings */
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 36) = proc_k[i * 2 + 1].address;
+        *(uint32_t*)(p_dmabuf_vaddr + (DRPAI_SGL_DRP_DESC_SIZE * i) + 40) = proc_k[i * 2 + 1].size;
+
+        DRPAI_DEBUG_PRINT("parm_address:0x%08X, parm_size:0x%08X\n", proc_k[i * 2 + 1].address, proc_k[i * 2 + 1].size);
+
+    }
+    __flush_dcache_area(p_dmabuf_vaddr, DRPAI_CMA_SIZE);
+
+    spin_lock_irqsave(&priv->lock, flags);
+    /* Init drpai_status.err */
+    priv->drpai_status.err = DRPAI_ERRINFO_SUCCESS;
+
+    /* IDLE -> RUN */
+    priv->drpai_status.status = DRPAI_STATUS_RUN;
+    DRPAI_DEBUG_PRINT("status2:   %d\n", priv->drpai_status.status);
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Kick */
+    (void)R_DRPAI_DRP_Start(drp_base_addr[0], 0, p_dmabuf_phyaddr);
+    (void)R_DRPAI_AIMAC_Start(aimac_base_address[0], 0, p_dmabuf_phyaddr + (DRPAI_SGL_DRP_DESC_SIZE * DRPAI_SEQ_NUM), &priv->lock);
+
+    DRPAI_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        /* Return semaphore when no ETIMEOUT */
+        up(&priv->sem);
+    }
+    DRPAI_DEBUG_PRINT("end.\n");
+    
+    return result;
+}
+
+/* Public to Kernel space */
+EXPORT_SYMBOL(drpai_open_k);
+EXPORT_SYMBOL(drpai_close_k);
+EXPORT_SYMBOL(drpai_start_k);
+/* ISP */
+#endif /* CONFIG_ARCH_R9A07G054 */
+
+module_platform_driver(drpai_platform_driver);
+MODULE_DEVICE_TABLE(of, drpai_match);
+
+#if defined(CONFIG_ARCH_R9A09G011GBG) 
+/* V2M conditional compilation */
+MODULE_DESCRIPTION("RZ/V2M DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2MA conditional compilation */
+MODULE_DESCRIPTION("RZ/V2MA DRPAI driver");
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+MODULE_DESCRIPTION("RZ/V2L DRPAI driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/drpai/drpai-reg.h b/drivers/drpai/drpai-reg.h
new file mode 100755
index 000000000000..2f88206cd8e6
--- /dev/null
+++ b/drivers/drpai/drpai-reg.h
@@ -0,0 +1,290 @@
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef R_DRPAI_REG_H
+#define R_DRPAI_REG_H
+
+/*--------------------------------------------------------------------------------------------------
+  DRP Initialization register
+--------------------------------------------------------------------------------------------------*/
+/* Clock */
+#define STPC_CLKGEN_CTRL                (0x81D930)
+#define STPC_CLKGEN_RST                 (0x81D840)
+#define STPC_CLKGEN_STBYWAIT            (0x81D860)
+#define STPC_CLKGEN_DIV                 (0x81D848)
+#define STPC_CLKE                       (0x81D810)
+/* Soft reset */
+#define STPC_SFTRST                     (0x81D800)
+/* DMAC */
+#define IDIF_DMACTLCW                   (0x819900)
+#define IDIF_DMACTLI0                   (0x819100)
+#define IDIF_DMACTLI1                   (0x819200)
+#define IDIF_DMACTLI2                   (0x819300)
+#define IDIF_DMACTLI3                   (0x819400)
+#define ODIF_DMACTLO0                   (0x81A100)
+#define ODIF_DMACTLO1                   (0x81A200)
+#define ODIF_DMACTLO2                   (0x81A300)
+#define ODIF_DMACTLO3                   (0x81A400)
+#define ODIF_DMACTLCR                   (0x81A900)
+/* Normal Interrupt mask */
+#define ODIF_INTMSK                     (0x81A004)
+/* Err Interrupt mask */
+#define IDIF_EINTMSK                    (0x81900C)
+#define IDIF_EINTMSK_DSC                (0x819014)
+#define ODIF_EINTMSK                    (0x81A00C)
+#define IDMAC_INTME                     (0x81B024)
+#define ODMAC_INTME                     (0x81C024)
+#define RAC_EINTM                       (0x81D008)
+/*--------------------------------------------------------------------------------------------------
+  DRP boot sequence register
+--------------------------------------------------------------------------------------------------*/
+#define DSCC_DPA                        (0x818108)
+#define DSCC_DCTL                       (0x818100)
+/*--------------------------------------------------------------------------------------------------
+  DPP NMLINT register
+--------------------------------------------------------------------------------------------------*/
+#define ODIF_INT                        (0x81A000)
+#define ODIF_INTCNTO0                   (0x81A118)
+#define ODIF_INTCNTO1                   (0x81A218)
+#define ODIF_INTCNTO2                   (0x81A318)
+#define ODIF_INTCNTO3                   (0x81A418)
+/*--------------------------------------------------------------------------------------------------
+  DRP ERRINT register
+--------------------------------------------------------------------------------------------------*/
+#define STPC_ERRINT_STS                 (0x81D808)
+#define DRP_ERRINTSTATUS                (0x3B0048)
+#define IDIF_EINT                       (0x819008)
+#define IDIF_EINT_DSC                   (0x819010)
+#define ODIF_EINT                       (0x81A008)
+#define IDMAC_INTSE                     (0x81B020)
+#define ODMAC_INTSE                     (0x81C020)
+#define RAC_EINTS                       (0x81D004)
+/*--------------------------------------------------------------------------------------------------
+  AI-MAC Initialization register
+--------------------------------------------------------------------------------------------------*/
+/* Clock */
+#define EXD0_STPC_CLKGEN_CTRL           (0x01D930)
+#define EXD0_STPC_CLKGEN_RST            (0x01D840)
+#define EXD0_STPC_CLKGEN_STBYWAIT       (0x01D860)
+#define EXD0_STPC_CLKGEN_DIV            (0x01D848)
+#define EXD0_STPC_CLKE                  (0x01D810)
+#define EXD1_STPC_CLKE                  (0x05D810)
+#define CLKRSTCON_CLKE                  (0x141808)
+/* Soft reset */
+#define EXD0_STPC_SFTRST                (0x01D800)
+#define EXD1_STPC_SFTRST                (0x05D800)
+#define CLKRSTCON_SFTRST                (0x141800)
+/* DMAC */
+#define EXD0_IDIF_DMACTLI0              (0x019100)
+#define EXD0_IDIF_DMACTLI1              (0x019200)
+#define EXD0_IDIF_DMACTLI2              (0x019300)
+#define EXD0_IDIF_DMACTLI3              (0x019400)
+#define EXD0_ODIF_DMACTLO0              (0x01A100)
+#define EXD0_ODIF_DMACTLO1              (0x01A200)
+#define EXD0_ODIF_DMACTLO2              (0x01A300)
+#define EXD0_ODIF_DMACTLO3              (0x01A400)
+#define EXD1_IDIF_DMACTLI0              (0x059100)
+#define EXD1_IDIF_DMACTLI1              (0x059200)
+#define EXD1_IDIF_DMACTLI2              (0x059300)
+#define EXD1_IDIF_DMACTLI3              (0x059400)
+#define EXD1_ODIF_DMACTLO0              (0x05A100)
+#define EXD1_ODIF_DMACTLO1              (0x05A200)
+#define EXD1_ODIF_DMACTLO2              (0x05A300)
+#define EXD1_ODIF_DMACTLO3              (0x05A400)
+/* Nml Interrupt mask */
+#define EXD1_ODIF_INTMSK                (0x05A004)
+/* Err Interrupt mask */
+#define AID_IDIF_EINTMSK                (0x11900C)
+#define AID_IDMAC_INTME                 (0x11B024)
+#define AIMRAC_EINTM                    (0x142008)
+#define CMDSEL_ERRMSK                   (0x140104)
+#define PRAM_INTMASK                    (0x200008)
+#define OSEL_DO_MSK0                    (0x180020)
+#define OSEL_DO_MSK1                    (0x180120)
+#define OSEL_DO_MSK2                    (0x180220)
+#define OSEL_DO_MSK3                    (0x180320)
+#define OSEL_DO_MSK4                    (0x180420)
+#define OSEL_DO_MSK5                    (0x180520)
+#define OSEL_DO_MSK6                    (0x180620)
+#define OSEL_DO_MSK7                    (0x180720)
+#define OSEL_DO_MSK8                    (0x180820)
+#define OSEL_DO_EN0                     (0x180010)
+#define OSEL_DO_EN1                     (0x180110)
+#define OSEL_DO_EN2                     (0x180210)
+#define OSEL_DO_EN3                     (0x180310)
+#define OSEL_DO_EN4                     (0x180410)
+#define OSEL_DO_EN5                     (0x180510)
+#define OSEL_DO_EN6                     (0x180610)
+#define OSEL_DO_EN7                     (0x180710)
+#define OSEL_DO_EN8                     (0x180810)
+#define MACTOP_ERR_MSK                  (0x1C000C)
+#define EXD0_IDIF_EINTMSK               (0x01900C)
+#define EXD1_IDIF_EINTMSK               (0x05900C)
+#define EXD0_ODIF_EINTMSK               (0x01A00C)
+#define EXD1_ODIF_EINTMSK               (0x05A00C)
+#define EXD0_IDMAC_INTME                (0x01B024)
+#define EXD1_IDMAC_INTME                (0x05B024)
+#define EXD0_ODMAC_INTME                (0x01C024)
+#define EXD1_ODMAC_INTME                (0x05C024)
+#define EXD0_RAC_EINTM                  (0x01D008)
+#define EXD1_RAC_EINTM                  (0x05D008)
+/*--------------------------------------------------------------------------------------------------
+  AI-MAC boot sequence register
+--------------------------------------------------------------------------------------------------*/
+#define AID_DSCC_DPA                    (0x118108)
+#define AID_DSCC_DCTL                   (0x118100)
+#define AID_IDIF_DMACTLI0               (0x119100)
+/*--------------------------------------------------------------------------------------------------
+  AI-MAC NMLINT register
+--------------------------------------------------------------------------------------------------*/
+#define EXD1_ODIF_INT                   (0x05A000)
+/*--------------------------------------------------------------------------------------------------
+  AI-MAC ERRINT register
+--------------------------------------------------------------------------------------------------*/
+#define INTMON_ERRINT                   (0x141008)
+#define AID_IDIF_EINT                   (0x119008)
+#define AID_IDMAC_INTSE                 (0x11B020)
+#define AIMRAC_EINTS                    (0x142004)
+#define CMDSEL_ERRSTS                   (0x140100)
+#define PRAM_INT                        (0x200000)
+#define OSEL_DO_ESTS0                   (0x180000)
+#define OSEL_DO_ESTS1                   (0x180100)
+#define OSEL_DO_ESTS2                   (0x180200)
+#define OSEL_DO_ESTS3                   (0x180300)
+#define OSEL_DO_ESTS4                   (0x180400)
+#define OSEL_DO_ESTS5                   (0x180500)
+#define OSEL_DO_ESTS6                   (0x180600)
+#define OSEL_DO_ESTS7                   (0x180700)
+#define OSEL_DO_ESTS8                   (0x180800)
+#define OSEL_AF_ESTS0                   (0x180004)
+#define OSEL_AF_ESTS1                   (0x180104)
+#define OSEL_AF_ESTS2                   (0x180204)
+#define OSEL_AF_ESTS3                   (0x180304)
+#define OSEL_AF_ESTS4                   (0x180404)
+#define OSEL_AF_ESTS5                   (0x180504)
+#define OSEL_AF_ESTS6                   (0x180604)
+#define OSEL_AF_ESTS7                   (0x180704)
+#define OSEL_AF_ESTS8                   (0x180804)
+#define OSEL_DO_FESTS0                  (0x181000)
+#define OSEL_DO_FESTS1                  (0x181100)
+#define OSEL_DO_FESTS2                  (0x181200)
+#define OSEL_DO_FESTS3                  (0x181300)
+#define OSEL_DO_FESTS4                  (0x181400)
+#define OSEL_DO_FESTS5                  (0x181500)
+#define OSEL_DO_FESTS6                  (0x181600)
+#define OSEL_DO_FESTS7                  (0x181700)
+#define OSEL_DO_FESTS8                  (0x181800)
+#define OSEL_AF_FESTS0                  (0x181004)
+#define OSEL_AF_FESTS1                  (0x181104)
+#define OSEL_AF_FESTS2                  (0x181204)
+#define OSEL_AF_FESTS3                  (0x181304)
+#define OSEL_AF_FESTS4                  (0x181404)
+#define OSEL_AF_FESTS5                  (0x181504)
+#define OSEL_AF_FESTS6                  (0x181604)
+#define OSEL_AF_FESTS7                  (0x181704)
+#define OSEL_AF_FESTS8                  (0x181804)
+#define MACTOP_ERR_STS                  (0x1C0008)
+#define MACCTL_FERR_STS                 (0x1C0800)
+#define EXD0_IDIF_EINT                  (0x019008)
+#define EXD1_IDIF_EINT                  (0x059008)
+#define EXD0_ODIF_EINT                  (0x01A008)
+#define EXD1_ODIF_EINT                  (0x05A008)
+#define EXD0_IDMAC_INTSE                (0x01B020)
+#define EXD1_IDMAC_INTSE                (0x05B020)
+#define EXD0_ODMAC_INTSE                (0x01C020)
+#define EXD1_ODMAC_INTSE                (0x05C020)
+#define EXD0_RAC_EINTS                  (0x01D004)
+#define EXD1_RAC_EINTS                  (0x05D004)
+/*--------------------------------------------------------------------------------------------------
+  AI-MAC Reset register
+--------------------------------------------------------------------------------------------------*/
+#define SYNCTBL_TBL0                    (0x140800)
+#define SYNCTBL_TBL1                    (0x140804)
+#define SYNCTBL_TBL2                    (0x140808)
+#define SYNCTBL_TBL3                    (0x14080C)
+#define SYNCTBL_TBL4                    (0x140810)
+#define SYNCTBL_TBL5                    (0x140814)
+#define SYNCTBL_TBL6                    (0x140818)
+#define SYNCTBL_TBL7                    (0x14081C)
+#define SYNCTBL_TBL8                    (0x140820)
+#define SYNCTBL_TBL9                    (0x140824)
+#define SYNCTBL_TBL10                   (0x140828)
+#define SYNCTBL_TBL11                   (0x14082C)
+#define SYNCTBL_TBL12                   (0x140830)
+#define SYNCTBL_TBL13                   (0x140834)
+#define SYNCTBL_TBL14                   (0x140838)
+#define SYNCTBL_TBL15                   (0x14083C)
+/*--------------------------------------------------------------------------------------------------
+  DRP Reset register
+--------------------------------------------------------------------------------------------------*/
+#define DRP_SYNCTBL_TBL0                (0x81E000)
+#define DRP_SYNCTBL_TBL1                (0x81E004)
+#define DRP_SYNCTBL_TBL2                (0x81E008)
+#define DRP_SYNCTBL_TBL3                (0x81E00C)
+#define DRP_SYNCTBL_TBL4                (0x81E010)
+#define DRP_SYNCTBL_TBL5                (0x81E014)
+#define DRP_SYNCTBL_TBL6                (0x81E018)
+#define DRP_SYNCTBL_TBL7                (0x81E01C)
+#define DRP_SYNCTBL_TBL8                (0x81E020)
+#define DRP_SYNCTBL_TBL9                (0x81E024)
+#define DRP_SYNCTBL_TBL10               (0x81E028)
+#define DRP_SYNCTBL_TBL11               (0x81E02C)
+#define DRP_SYNCTBL_TBL12               (0x81E030)
+#define DRP_SYNCTBL_TBL13               (0x81E034)
+#define DRP_SYNCTBL_TBL14               (0x81E038)
+#define DRP_SYNCTBL_TBL15               (0x81E03C)
+/*--------------------------------------------------------------------------------------------------
+  DRP-AI Internal state register
+--------------------------------------------------------------------------------------------------*/
+#define DSCC_PAMON                      (0x818118)
+#define AID_DSCC_PAMON                  (0x118118)
+/*--------------------------------------------------------------------------------------------------
+  Bit manipulation
+--------------------------------------------------------------------------------------------------*/
+#define DRPAI_BIT0                      (0x00000001u)
+#define DRPAI_BIT1                      (0x00000002u)
+#define DRPAI_BIT2                      (0x00000004u)
+#define DRPAI_BIT3                      (0x00000008u)
+#define DRPAI_BIT4                      (0x00000010u)
+#define DRPAI_BIT5                      (0x00000020u)
+#define DRPAI_BIT6                      (0x00000040u)
+#define DRPAI_BIT7                      (0x00000080u)
+#define DRPAI_BIT8                      (0x00000100u)
+#define DRPAI_BIT9                      (0x00000200u)
+#define DRPAI_BIT10                     (0x00000400u)
+#define DRPAI_BIT11                     (0x00000800u)
+#define DRPAI_BIT12                     (0x00001000u)
+#define DRPAI_BIT13                     (0x00002000u)
+#define DRPAI_BIT14                     (0x00004000u)
+#define DRPAI_BIT15                     (0x00008000u)
+#define DRPAI_BIT16                     (0x00010000u)
+#define DRPAI_BIT17                     (0x00020000u)
+#define DRPAI_BIT18                     (0x00040000u)
+#define DRPAI_BIT19                     (0x00080000u)
+#define DRPAI_BIT20                     (0x00100000u)
+#define DRPAI_BIT21                     (0x00200000u)
+#define DRPAI_BIT22                     (0x00400000u)
+#define DRPAI_BIT23                     (0x00800000u)
+#define DRPAI_BIT24                     (0x01000000u)
+#define DRPAI_BIT25                     (0x02000000u)
+#define DRPAI_BIT26                     (0x04000000u)
+#define DRPAI_BIT27                     (0x08000000u)
+#define DRPAI_BIT28                     (0x10000000u)
+#define DRPAI_BIT29                     (0x20000000u)
+#define DRPAI_BIT30                     (0x40000000u)
+#define DRPAI_BIT31                     (0x80000000u)
+
+#endif /* R_DRPAI_REG_H */
diff --git a/drivers/media/i2c/ov5645.c b/drivers/media/i2c/ov5645.c
index a6c17d15d754..75c18b577d73 100644
--- a/drivers/media/i2c/ov5645.c
+++ b/drivers/media/i2c/ov5645.c
@@ -61,6 +61,31 @@
 #define OV5645_SDE_SAT_U		0x5583
 #define OV5645_SDE_SAT_V		0x5584
 
+enum ov5645_frame_rate {
+	OV5645_15_FPS = 0,
+	OV5645_30_FPS,
+	OV5645_45_FPS,
+	OV5645_60_FPS,
+	OV5645_NUM_FRAMERATES,
+};
+
+static const int ov5645_framerates[] = {
+	[OV5645_15_FPS] = 15,
+	[OV5645_30_FPS] = 30,
+	[OV5645_45_FPS] = 45,
+	[OV5645_60_FPS] = 60,
+};
+
+struct ov5645_pixfmt {
+	u32 code;
+	u32 colorspace;
+};
+
+static const struct ov5645_pixfmt ov5645_formats[] = {
+	{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_SRGB, },
+};
+
+
 /* regulator supplies */
 static const char * const ov5645_supply_name[] = {
 	"vdddo", /* Digital I/O (1.8V) supply */
@@ -82,6 +107,7 @@ struct ov5645_mode_info {
 	u32 data_size;
 	u32 pixel_clock;
 	u32 link_freq;
+	u32 max_fps;
 };
 
 struct ov5645 {
@@ -97,6 +123,8 @@ struct ov5645 {
 	struct regulator_bulk_data supplies[OV5645_NUM_SUPPLIES];
 
 	const struct ov5645_mode_info *current_mode;
+	enum ov5645_frame_rate current_fr;
+	struct v4l2_fract frame_interval;
 
 	struct v4l2_ctrl_handler ctrls;
 	struct v4l2_ctrl *pixel_clock;
@@ -112,6 +140,8 @@ struct ov5645 {
 
 	struct gpio_desc *enable_gpio;
 	struct gpio_desc *rst_gpio;
+
+	bool streaming;
 };
 
 static inline struct ov5645 *to_ov5645(struct v4l2_subdev *sd)
@@ -361,6 +391,198 @@ static const struct reg_value ov5645_global_init_setting[] = {
 	{ OV5645_PAD_OUTPUT00, 0x70 }
 };
 
+static const struct reg_value ov5645_setting_VGA_640_480[] = {
+	{ 0x3612, 0xa9 },
+	{ 0x3614, 0x50 },
+	{ 0x3618, 0x00 },
+	{ 0x3034, 0x18 },
+	{ 0x3035, 0x21 },
+	{ 0x3036, 0x70 },
+	{ 0x3600, 0x09 },
+	{ 0x3601, 0x43 },
+	{ 0x3708, 0x66 },
+	{ 0x370c, 0xc3 },
+	{ 0x3800, 0x02 },
+	{ 0x3801, 0x80 },
+	{ 0x3802, 0x01 },
+	{ 0x3803, 0xd4 },
+	{ 0x3804, 0x0a },
+	{ 0x3805, 0x3f },
+	{ 0x3806, 0x07 },
+	{ 0x3807, 0xeb },
+	{ 0x3808, 0x02 },
+	{ 0x3809, 0x80 },
+	{ 0x380a, 0x01 },
+	{ 0x380b, 0xe0 },
+	{ 0x380c, 0x07 },
+	{ 0x380d, 0x68 },
+	{ 0x380e, 0x03 },
+	{ 0x380f, 0xd8 },
+	{ 0x3813, 0x06 },
+	{ 0x3814, 0x31 },
+	{ 0x3815, 0x31 },
+	{ 0x3820, 0x41 },
+	{ 0x3a02, 0x03 },
+	{ 0x3a03, 0xd8 },
+	{ 0x3a08, 0x01 },
+	{ 0x3a09, 0xf8 },
+	{ 0x3a0a, 0x01 },
+	{ 0x3a0b, 0xa4 },
+	{ 0x3a0e, 0x02 },
+	{ 0x3a0d, 0x02 },
+	{ 0x3a14, 0x03 },
+	{ 0x3a15, 0xd8 },
+	{ 0x3a18, 0x00 },
+	{ 0x4004, 0x02 },
+	{ 0x4005, 0x18 },
+	{ 0x4300, 0x32 },
+	{ 0x4202, 0x00 }
+};
+
+static const struct reg_value ov5645_setting_30fps_NTSC_720_480[] = {
+	{ 0x3612, 0xa9 },
+	{ 0x3614, 0x50 },
+	{ 0x3618, 0x00 },
+	{ 0x3034, 0x18 },
+	{ 0x3035, 0x11 },
+	{ 0x3036, 0x54 },
+	{ 0x3600, 0x09 },
+	{ 0x3601, 0x43 },
+	{ 0x3708, 0x66 },
+	{ 0x370c, 0xc3 },
+	{ 0x3800, 0x00 },
+	{ 0x3801, 0x00 },
+	{ 0x3802, 0x00 },
+	{ 0x3803, 0x6c },
+	{ 0x3804, 0x0a },
+	{ 0x3805, 0x3f },
+	{ 0x3806, 0x07 },
+	{ 0x3807, 0x33 },
+	{ 0x3808, 0x02 },
+	{ 0x3809, 0xd0 },
+	{ 0x380a, 0x01 },
+	{ 0x380b, 0xe0 },
+	{ 0x380c, 0x07 },
+	{ 0x380d, 0x68 },
+	{ 0x380e, 0x03 },
+	{ 0x380f, 0xd8 },
+	{ 0x3813, 0x06 },
+	{ 0x3814, 0x31 },
+	{ 0x3815, 0x31 },
+	{ 0x3820, 0x41 },
+	{ 0x3a02, 0x03 },
+	{ 0x3a03, 0xd8 },
+	{ 0x3a08, 0x01 },
+	{ 0x3a09, 0xf8 },
+	{ 0x3a0a, 0x01 },
+	{ 0x3a0b, 0xa4 },
+	{ 0x3a0e, 0x02 },
+	{ 0x3a0d, 0x02 },
+	{ 0x3a14, 0x03 },
+	{ 0x3a15, 0xd8 },
+	{ 0x3a18, 0x00 },
+	{ 0x4004, 0x02 },
+	{ 0x4005, 0x18 },
+	{ 0x4300, 0x32 },
+	{ 0x4202, 0x00 }
+};
+
+static const struct reg_value ov5645_setting_720P_1280_720[] = {
+	{ 0x3612, 0xa9 },
+	{ 0x3614, 0x50 },
+	{ 0x3618, 0x00 },
+	{ 0x3034, 0x18 },
+	{ 0x3035, 0x11 },
+	{ 0x3036, 0x54 },
+	{ 0x3500, 0x00},
+	{ 0x3501, 0x01},
+	{ 0x3502, 0x00},
+	{ 0x350a, 0x00},
+	{ 0x350b, 0x3f},
+	{ 0x3600, 0x0a},
+	{ 0x3601, 0x75},
+	{ 0x3620, 0x33},
+	{ 0x3621, 0xe0},
+	{ 0x3622, 0x01},
+	{ 0x3630, 0x2d},
+	{ 0x3631, 0x00},
+	{ 0x3632, 0x32},
+	{ 0x3633, 0x52},
+	{ 0x3634, 0x70},
+	{ 0x3635, 0x13},
+	{ 0x3636, 0x03},
+	{ 0x3702, 0x6e},
+	{ 0x3703, 0x52},
+	{ 0x3704, 0xa0},
+	{ 0x3705, 0x33},
+	{ 0x3708, 0x66},
+	{ 0x3709, 0x12},
+	{ 0x370b, 0x61},
+	{ 0x370c, 0xc3},
+	{ 0x370f, 0x10},
+	{ 0x3715, 0x08},
+	{ 0x3717, 0x01},
+	{ 0x371b, 0x20},
+	{ 0x3731, 0x22},
+	{ 0x3739, 0x70},
+	{ 0x3901, 0x0a},
+	{ 0x3905, 0x02},
+	{ 0x3906, 0x10},
+	{ 0x3719, 0x86},
+	{ 0x3800, 0x00},
+	{ 0x3801, 0x00},
+	{ 0x3802, 0x00},
+	{ 0x3803, 0xfa},
+	{ 0x3804, 0x0a},
+	{ 0x3805, 0x3f},
+	{ 0x3806, 0x06},
+	{ 0x3807, 0xa9},
+	{ 0x3808, 0x05},
+	{ 0x3809, 0x00},
+	{ 0x380a, 0x02},
+	{ 0x380b, 0xd0},
+	{ 0x380c, 0x07},
+	{ 0x380d, 0x64},
+	{ 0x380e, 0x02},
+	{ 0x380f, 0xe4},
+	{ 0x3810, 0x00},
+	{ 0x3811, 0x10},
+	{ 0x3812, 0x00},
+	{ 0x3813, 0x04},
+	{ 0x3814, 0x31},
+	{ 0x3815, 0x31},
+	{ 0x3820, 0x41},
+	{ 0x3821, 0x07},
+	{ 0x3824, 0x01},
+	{ 0x3826, 0x03},
+	{ 0x3828, 0x08},
+	{ 0x3a02, 0x02},
+	{ 0x3a03, 0xe4},
+	{ 0x3a08, 0x01},
+	{ 0x3a09, 0xbc},
+	{ 0x3a0a, 0x01},
+	{ 0x3a0b, 0x72},
+	{ 0x3a0e, 0x01},
+	{ 0x3a0d, 0x02},
+	{ 0x3a14, 0x02},
+	{ 0x3a15, 0xe4},
+	{ 0x3a18, 0x00},
+	{ 0x3a19, 0xf8},
+	{ 0x3c01, 0x34},
+	{ 0x3c04, 0x28},
+	{ 0x3c05, 0x98},
+	{ 0x3c07, 0x07},
+	{ 0x3c09, 0xc2},
+	{ 0x3c0a, 0x9c},
+	{ 0x3c0b, 0x40},
+	{ 0x3c01, 0x34},
+	{ 0x4004, 0x02 },
+	{ 0x4005, 0x18 },
+	{ 0x4300, 0x32 },
+	{ 0x4202, 0x00 }
+
+};
+
 static const struct reg_value ov5645_setting_sxga[] = {
 	{ 0x3612, 0xa9 },
 	{ 0x3614, 0x50 },
@@ -515,13 +737,41 @@ static const s64 link_freq[] = {
 };
 
 static const struct ov5645_mode_info ov5645_mode_info_data[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.data = ov5645_setting_VGA_640_480,
+		.data_size = ARRAY_SIZE(ov5645_setting_VGA_640_480),
+		.pixel_clock = 112000000,
+		.link_freq = 0, /* an index in link_freq[] */
+		.max_fps = OV5645_30_FPS
+	},
+	{
+		.width = 720,
+		.height = 480,
+		.data = ov5645_setting_30fps_NTSC_720_480,
+		.data_size = ARRAY_SIZE(ov5645_setting_30fps_NTSC_720_480),
+		.pixel_clock = 112000000,
+		.link_freq = 0, /* an index in link_freq[] */
+		.max_fps = OV5645_45_FPS
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.data = ov5645_setting_720P_1280_720,
+		.data_size = ARRAY_SIZE(ov5645_setting_720P_1280_720),
+		.pixel_clock = 112000000,
+		.link_freq = 0, /* an index in link_freq[] */
+		.max_fps = OV5645_60_FPS
+	},
 	{
 		.width = 1280,
 		.height = 960,
 		.data = ov5645_setting_sxga,
 		.data_size = ARRAY_SIZE(ov5645_setting_sxga),
 		.pixel_clock = 112000000,
-		.link_freq = 0 /* an index in link_freq[] */
+		.link_freq = 0, /* an index in link_freq[] */
+		.max_fps = OV5645_30_FPS
 	},
 	{
 		.width = 1920,
@@ -529,7 +779,8 @@ static const struct ov5645_mode_info ov5645_mode_info_data[] = {
 		.data = ov5645_setting_1080p,
 		.data_size = ARRAY_SIZE(ov5645_setting_1080p),
 		.pixel_clock = 168000000,
-		.link_freq = 1 /* an index in link_freq[] */
+		.link_freq = 1, /* an index in link_freq[] */
+		.max_fps = OV5645_30_FPS
 	},
 	{
 		.width = 2592,
@@ -537,7 +788,8 @@ static const struct ov5645_mode_info ov5645_mode_info_data[] = {
 		.data = ov5645_setting_full,
 		.data_size = ARRAY_SIZE(ov5645_setting_full),
 		.pixel_clock = 168000000,
-		.link_freq = 1 /* an index in link_freq[] */
+		.link_freq = 1, /* an index in link_freq[] */
+		.max_fps = OV5645_15_FPS
 	},
 };
 
@@ -585,6 +837,27 @@ static int ov5645_read_reg(struct ov5645 *ov5645, u16 reg, u8 *val)
 	return 0;
 }
 
+static const struct ov5645_mode_info *
+ov5645_find_mode(struct ov5645 *sensor, enum ov5645_frame_rate fr,
+		 int width, int height, bool nearest)
+{
+	const struct ov5645_mode_info *mode;
+
+	mode = v4l2_find_nearest_size(ov5645_mode_info_data,
+			       ARRAY_SIZE(ov5645_mode_info_data),
+			       width, height,
+			       width, height);
+	if (!mode ||
+	    (!nearest && (mode->width != width || mode->height != height)))
+		return NULL;
+
+	/* Check to see if the current mode exceeds the max frame rate */
+	if (ov5645_framerates[fr] > ov5645_framerates[mode->max_fps])
+		return NULL;
+
+	return mode;
+}
+
 static int ov5645_set_aec_mode(struct ov5645 *ov5645, u32 mode)
 {
 	u8 val = ov5645->aec_pk_manual;
@@ -712,6 +985,49 @@ static int ov5645_s_power(struct v4l2_subdev *sd, int on)
 	return ret;
 }
 
+static int ov5645_try_frame_interval(struct ov5645 *sensor,
+				     struct v4l2_fract *fi,
+				     u32 width, u32 height)
+{
+	const struct ov5645_mode_info *mode;
+	enum ov5645_frame_rate rate = OV5645_15_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	minfps = ov5645_framerates[OV5645_15_FPS];
+	maxfps = ov5645_framerates[OV5645_60_FPS];
+
+	if (fi->numerator == 0) {
+		fi->denominator = maxfps;
+		fi->numerator = 1;
+		rate = OV5645_60_FPS;
+		goto find_mode;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	for (i = 0; i < ARRAY_SIZE(ov5645_framerates); i++) {
+		int curr_fps = ov5645_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+find_mode:
+	mode = ov5645_find_mode(sensor, rate, width, height, false);
+	return mode ? rate : -EINVAL;
+}
+
 static int ov5645_set_saturation(struct ov5645 *ov5645, s32 value)
 {
 	u32 reg_value = (value * 0x10) + 0x40;
@@ -866,6 +1182,86 @@ static int ov5645_enum_frame_size(struct v4l2_subdev *subdev,
 	return 0;
 }
 
+static int ov5645_enum_frame_interval(
+	struct v4l2_subdev *sd,
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ov5645 *sensor = to_ov5645(sd);
+	struct v4l2_fract tpf;
+	int ret;
+
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index >= OV5645_NUM_FRAMERATES)
+		return -EINVAL;
+
+	tpf.numerator = 1;
+	tpf.denominator = ov5645_framerates[fie->index];
+
+	ret = ov5645_try_frame_interval(sensor, &tpf,
+					fie->width, fie->height);
+	if (ret < 0)
+		return -EINVAL;
+
+	fie->interval = tpf;
+	return 0;
+}
+
+static int ov5645_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov5645 *sensor = to_ov5645(sd);
+
+	mutex_lock(&sensor->power_lock);
+	fi->interval = sensor->frame_interval;
+	mutex_unlock(&sensor->power_lock);
+
+	return 0;
+}
+
+static int ov5645_s_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov5645 *sensor = to_ov5645(sd);
+	const struct ov5645_mode_info *mode;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->power_lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mode = sensor->current_mode;
+
+	frame_rate = ov5645_try_frame_interval(sensor, &fi->interval,
+					       mode->width, mode->height);
+	if (frame_rate < 0)
+		frame_rate = OV5645_15_FPS;
+
+	mode = ov5645_find_mode(sensor, frame_rate, mode->width,
+				mode->height, true);
+	if (!mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mode != sensor->current_mode ||
+	    frame_rate != sensor->current_fr) {
+		sensor->current_fr = frame_rate;
+		sensor->frame_interval = fi->interval;
+		sensor->current_mode = mode;
+	}
+out:
+	mutex_unlock(&sensor->power_lock);
+	return ret;
+}
+
 static struct v4l2_mbus_framefmt *
 __ov5645_get_pad_format(struct ov5645 *ov5645,
 			struct v4l2_subdev_pad_config *cfg,
@@ -1012,7 +1408,10 @@ static int ov5645_s_stream(struct v4l2_subdev *subdev, int enable)
 				       OV5645_SYSTEM_CTRL0_START);
 		if (ret < 0)
 			return ret;
+
+		ov5645->streaming = enable;
 	} else {
+		ov5645->streaming = false;
 		ret = ov5645_write_reg(ov5645, OV5645_IO_MIPI_CTRL00, 0x40);
 		if (ret < 0)
 			return ret;
@@ -1031,6 +1430,8 @@ static const struct v4l2_subdev_core_ops ov5645_core_ops = {
 };
 
 static const struct v4l2_subdev_video_ops ov5645_video_ops = {
+	.g_frame_interval = ov5645_g_frame_interval,
+	.s_frame_interval = ov5645_s_frame_interval,
 	.s_stream = ov5645_s_stream,
 };
 
@@ -1041,6 +1442,7 @@ static const struct v4l2_subdev_pad_ops ov5645_subdev_pad_ops = {
 	.get_fmt = ov5645_get_format,
 	.set_fmt = ov5645_set_format,
 	.get_selection = ov5645_get_selection,
+	.enum_frame_interval = ov5645_enum_frame_interval,
 };
 
 static const struct v4l2_subdev_ops ov5645_subdev_ops = {
diff --git a/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c b/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c
index 8fd7f1dd8cb9..af773269d5cc 100644
--- a/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c
+++ b/drivers/media/platform/rzg2l-cru/rzg2l-csi2.c
@@ -103,9 +103,11 @@ struct rzg2l_csi2_format {
 static const struct rzg2l_csi2_format rzg2l_csi2_formats[] = {
 	{ .code = MEDIA_BUS_FMT_RGB565_2X8_LE,	.bpp = 16 },
 	{ .code = MEDIA_BUS_FMT_RGB888_1X24,	.bpp = 24 },
+	{ .code = MEDIA_BUS_FMT_BGR888_1X24,	.bpp = 24 },
 	{ .code = MEDIA_BUS_FMT_UYVY8_1X16,	.bpp = 16 },
 	{ .code = MEDIA_BUS_FMT_YUYV8_1X16,	.bpp = 16 },
 	{ .code = MEDIA_BUS_FMT_UYVY8_2X8,	.bpp = 16 },
+	{ .code = MEDIA_BUS_FMT_YUYV8_2X8,	.bpp = 16 },
 	{ .code = MEDIA_BUS_FMT_YUYV10_2X10,	.bpp = 20 },
 	{ .code = MEDIA_BUS_FMT_SRGGB8_1X8,	.bpp = 8 },
 	{ .code = MEDIA_BUS_FMT_SGRBG8_1X8,	.bpp = 8 },
diff --git a/drivers/media/platform/rzg2l-cru/rzg2l-dma.c b/drivers/media/platform/rzg2l-cru/rzg2l-dma.c
index de7e3daa6095..442281d3706f 100644
--- a/drivers/media/platform/rzg2l-cru/rzg2l-dma.c
+++ b/drivers/media/platform/rzg2l-cru/rzg2l-dma.c
@@ -456,11 +456,13 @@ static int rzg2l_cru_mc_validate_format(struct rzg2l_cru_dev *cru,
 	} else {
 		switch (fmt.format.code) {
 		case MEDIA_BUS_FMT_UYVY8_2X8:
+		case MEDIA_BUS_FMT_YUYV8_2X8:
 		case MEDIA_BUS_FMT_UYVY10_2X10:
 		case MEDIA_BUS_FMT_RGB444_1X12:
 		case MEDIA_BUS_FMT_RGB565_2X8_LE:
 		case MEDIA_BUS_FMT_RGB666_1X18:
 		case MEDIA_BUS_FMT_RGB888_1X24:
+		case MEDIA_BUS_FMT_BGR888_1X24:
 		case MEDIA_BUS_FMT_SRGGB8_1X8:
 		case MEDIA_BUS_FMT_SGRBG8_1X8:
 		case MEDIA_BUS_FMT_SGBRG8_1X8:
@@ -616,6 +618,10 @@ static void rzg2l_cru_csi2_setup(struct rzg2l_cru_dev *cru)
 		icnmc = ICnMC_INF_YUV8_422;
 		cru->input_fmt = YUV;
 		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+		icnmc = ICnMC_INF_YUV8_422;
+		cru->input_fmt = YUV;
+		break;
 	case MEDIA_BUS_FMT_UYVY10_2X10:
 		icnmc = ICnMC_INF_YUV10_422;
 		cru->input_fmt = YUV;
@@ -632,7 +638,7 @@ static void rzg2l_cru_csi2_setup(struct rzg2l_cru_dev *cru)
 		icnmc = ICnMC_INF_RGB666;
 		cru->input_fmt = RGB;
 		break;
-	case MEDIA_BUS_FMT_RGB888_1X24:
+	case MEDIA_BUS_FMT_BGR888_1X24:
 		icnmc = ICnMC_INF_RGB888;
 		cru->input_fmt = RGB;
 		break;
diff --git a/include/linux/drpai.h b/include/linux/drpai.h
new file mode 100755
index 000000000000..8b6cf6bbf0a0
--- /dev/null
+++ b/include/linux/drpai.h
@@ -0,0 +1,22 @@
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DRPAI_H
+#define _DRPAI_H
+
+#include <uapi/linux/drpai.h>
+
+#endif /* _DRPAI_H */
diff --git a/include/uapi/linux/drpai.h b/include/uapi/linux/drpai.h
new file mode 100755
index 000000000000..ee1f32a946f0
--- /dev/null
+++ b/include/uapi/linux/drpai.h
@@ -0,0 +1,129 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Driver for the Renesas RZ/V2M RZ/V2MA RZ/V2L DRP-AI unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI__DRPAI_H
+#define _UAPI__DRPAI_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#define DRPAI_IO_TYPE               (46)
+#define DRPAI_ASSIGN                _IOW (DRPAI_IO_TYPE, 0, drpai_data_t)
+#define DRPAI_START                 _IOW (DRPAI_IO_TYPE, 1, drpai_data_t)
+#define DRPAI_RESET                 _IO  (DRPAI_IO_TYPE, 2)
+#define DRPAI_GET_STATUS            _IOR (DRPAI_IO_TYPE, 3, drpai_status_t)
+#define DRPAI_REG_DUMP              _IO  (DRPAI_IO_TYPE, 5)
+#define DRPAI_ASSIGN_PARAM          _IOW (DRPAI_IO_TYPE, 6, drpai_assign_param_t)  /* Since the sturecture size is different,       */
+                                                                                   /* it will be a different ID from DRPAI_SET_SEQ. */
+#define DRPAI_PREPOST_CROP          _IOW (DRPAI_IO_TYPE, 7, drpai_crop_t)
+#define DRPAI_PREPOST_INADDR        _IOW (DRPAI_IO_TYPE, 8, drpai_inout_t)
+#define DRPAI_SET_SEQ               _IOW (DRPAI_IO_TYPE, 6, drpai_seq_t)           /* Since the sturecture size is different,            */
+                                                                                   /* it will be a different ID from DRPAI_ASSIGN_PARAM. */
+#define DRPAI_ASSIGN_DYNAMIC        _IOW (DRPAI_IO_TYPE, 10, drpai_data_dynamic_t)
+#define DRPAI_GET_DRPAI_AREA        _IOR (DRPAI_IO_TYPE, 11, drpai_data_t)
+
+#define DRPAI_INDEX_NUM             (7)
+#define DRPAI_INDEX_INPUT           (0)
+#define DRPAI_INDEX_DRP_DESC        (1)
+#define DRPAI_INDEX_DRP_CFG         (2)
+#define DRPAI_INDEX_DRP_PARAM       (3)
+#define DRPAI_INDEX_AIMAC_DESC      (4)
+#define DRPAI_INDEX_WEIGHT          (5)
+#define DRPAI_INDEX_OUTPUT          (6)
+#define DRPAI_STATUS_INIT           (0)
+#define DRPAI_STATUS_IDLE           (1)
+#define DRPAI_STATUS_RUN            (2)
+#define DRPAI_ERRINFO_SUCCESS       (0)
+#define DRPAI_ERRINFO_DRP_ERR       (-1)
+#define DRPAI_ERRINFO_AIMAC_ERR     (-2)
+#define DRPAI_ERRINFO_RESET         (-3)
+#define DRPAI_RESERVED_NUM          (10)
+#define DRPAI_SEQ_NUM               (20)
+#define DRPAI_EXE_AI                (1)
+#define DRPAI_EXE_DRP               (2)
+#define DRPAI_DRP_NOLOAD            (0)
+#define DRPAI_MAX_NODE_NAME         (256)
+#define DRPAI_FILE_TYPE_DESC        (0x10000)
+#define DRPAI_FILE_TYPE_PARAM       (0x20000)
+#define DRPAI_FILE_TYPE_DRP_DESC    (DRPAI_FILE_TYPE_DESC  | DRPAI_INDEX_DRP_DESC)
+#define DRPAI_FILE_TYPE_DRP_CFG     (                        DRPAI_INDEX_DRP_CFG)
+#define DRPAI_FILE_TYPE_DRP_PARAM   (DRPAI_FILE_TYPE_PARAM | DRPAI_INDEX_DRP_PARAM)
+#define DRPAI_FILE_TYPE_AIMAC_DESC  (DRPAI_FILE_TYPE_DESC  | DRPAI_INDEX_AIMAC_DESC)
+#define DRPAI_FILE_TYPE_WEIGHT      (                        DRPAI_INDEX_WEIGHT)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drpai_data
+{
+    uint32_t        address;
+    uint32_t        size;
+} drpai_data_t;
+
+typedef struct drpai_data_dynamic
+{
+    uint32_t        start_address;
+    uint32_t        offset;
+    uint32_t        size;
+    uint32_t        file_type;
+} drpai_data_dynamic_t;
+
+typedef struct drpai_status
+{
+    uint32_t        status;
+    int32_t         err;
+    uint32_t        reserved[DRPAI_RESERVED_NUM];
+} drpai_status_t;
+
+typedef struct drpai_assign_param
+{
+    uint32_t     info_size;
+    drpai_data_t obj;
+} drpai_assign_param_t;
+
+typedef struct drpai_crop
+{
+    uint16_t     img_owidth;
+    uint16_t     img_oheight;
+    uint16_t     pos_x;
+    uint16_t     pos_y;
+    drpai_data_t obj;
+} drpai_crop_t;
+
+typedef struct drpai_inout
+{
+    char         name[DRPAI_MAX_NODE_NAME];
+    drpai_data_t data;
+    drpai_data_t obj;
+} drpai_inout_t;
+
+typedef struct drpai_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRPAI_SEQ_NUM];
+} drpai_seq_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UAPI__DRPAI_H */
diff --git a/mm/frame_vector.c b/mm/frame_vector.c
index 0e589a9a8801..e4a252dd3b4b 100644
--- a/mm/frame_vector.c
+++ b/mm/frame_vector.c
@@ -37,6 +37,9 @@ int get_vaddr_frames(unsigned long start, unsigned int nr_frames,
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
 	int ret = 0;
+#if defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG) || defined(CONFIG_ARCH_R9A07G054)
+	int err;
+#endif
 	int locked;
 
 	if (nr_frames == 0)
@@ -73,14 +76,44 @@ int get_vaddr_frames(unsigned long start, unsigned int nr_frames,
 		vec->is_pfns = false;
 		ret = pin_user_pages_locked(start, nr_frames,
 			gup_flags, (struct page **)(vec->ptrs), &locked);
+#if defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG) || defined(CONFIG_ARCH_R9A07G054)
+		goto out;
+#else
 		if (likely(ret > 0))
 			goto out;
+#endif
 	}
 
+#if defined(CONFIG_ARCH_R9A09G011GBG) || defined(CONFIG_ARCH_R9A09G055MA3GBG) || defined(CONFIG_ARCH_R9A07G054)
+	vec->got_ref = false;
+	vec->is_pfns = true;
+	do {
+		unsigned long *nums = frame_vector_pfns(vec);
+
+		while (ret < nr_frames && start + PAGE_SIZE <= vma->vm_end) {
+			err = follow_pfn(vma, start, &nums[ret]);
+			if (err) {
+				if (ret == 0)
+					ret = err;
+				goto out;
+			}
+			start += PAGE_SIZE;
+			ret++;
+		}
+		/*
+		 * We stop if we have enough pages or if VMA doesn't completely
+		 * cover the tail page.
+		 */
+		if (ret >= nr_frames || start < vma->vm_end)
+			break;
+		vma = find_vma_intersection(mm, start, start + 1);
+	} while (vma && vma->vm_flags & (VM_IO | VM_PFNMAP));
+#else
 	/* This used to (racily) return non-refcounted pfns. Let people know */
 	WARN_ONCE(1, "get_vaddr_frames() cannot follow VM_IO mapping");
 	vec->nr_frames = 0;
 
+#endif
 out:
 	if (locked)
 		mmap_read_unlock(mm);
-- 
2.34.1

